{
    "version": "https://jsonfeed.org/version/1",
    "title": "0o3q",
    "home_page_url": "https://0o3q.github.io/",
    "feed_url": "https://0o3q.github.io/feed.json",
    "description": "그냥 대학생의 보안 블로그",
    "icon": "https://0o3q.github.io/apple-touch-icon.png",
    "favicon": "https://0o3q.github.io/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "0o3q",
        "url": null,
        "avatar": null
    },
    
"items": [
    
        {
            "id": "https://0o3q.github.io/2023/04/12/hash",
            "title": "해시",
            "summary": null,
            "content_text": "해시해시함수(hash function)란 임의의 길이를 가진 데이터를 고정된 길이의 데이터로 매핑되는 함수이다. 해시함수의 결과값을 해시값이라고 부른다.해시함수는 데이터를 자르거나 치환하거나 위치를 변경하는 방법으로 해시값을 생성하므로, 원본 데이터의 정보를 상실하게 되어 생성된 해시값은 원래 데이터로 복원할 수 없다.즉, 해시는 일방향성을 가진다.해시값은 2개의 다른 입력값에 대해 특정 확률로 동일한 해시값이 나올 수 있다. 이와 같이 서로 다른 입력값에 대해 동일한 해시값이 나오는 상황을 해시 충돌이라고 한다.해시충돌이 발생하는 특정 확률이라는것이 매우 작은 값이므로 통계적으로 큰 의미가 없다고 볼 수 있다.128비트 크기의 해시값을 출력하는 해시함수의 경우, 해시충돌이 발생하는 경우는 1/2^128로 매우 작다. 최근에는 256비트, 512비트 크기의 해시값을 출력하는 해시함수가 사용되기 때문에 해시충돌 발생 확률은 거의 0에 가깝다.해시함수에 입력되는 값이 1바이트만 바뀌어도 해시값은 완전히 다른 값으로 출력된다.MD5Message-Digest algorithm 5의 약자로 1991년 만들어진 128비트의 길이의 해시값을 출력하는 해시함수이다. MD5는 패스워드의 암호화나 네트워크의 장비인 스위치, 라우터 등에서 장비간 상호 인증을 위해 활용되기도 한다.하지만 MD5는 128비트의 다소 작은 크기의 해시값 출력과 알고리즘 자체의 결함도 알려져 있어 최근에는 네트워크로 전송되는 파일의 무결성 검증 등에서만 활용되는 추세이다.파이썬에서 MD5해시함수를 사용하려면 파이썬 자체에서 사용하는 hashlib모듈의 md5나 Pycryptodome 모듈에서 제공하는 MD5를 임포트하면 된다.from hashlib import md5#orfrom Crypto.Hash import MD5다음은 파이썬의 hashlib 모듈이 제공하는 md5를 이용하여 “I love Python”이라는 메세지에 MD5해시값을 16진수로 출력하는 코드다.from hashlib import md5msg = \"I love Python\"m = md5()m.update(msg.encode('UTF-8'))ret = m.hexdigest()print(ret)“I love Python”에 대한 MD5 해시값은 16진수로 다음과 같다.27eb2f69c24aa5f3503a6ae610f23a83SHASecure Hash Algorithm의 약자로 1993년 미국의 NSA가 만들고 미국 국립표준기술연구소에서 표준으로 제정된 해시함수이다. SHA는 SHA-0, SHA-1, SHA-2, SHA-3로 발전되어 왔다. 토렌트로 잘 알려진 P2P 파일 공유 시스템의 원조격인 비트토렌트에서 파일의 무경성이나 인덱싱을 위해 SHA-1 알고리즘이 활용되었고, 패스워드 암호화나 블록체인 등에서는 SHA-2 시리즈 중 SHA-256 알고리즘이 광법위하게 사용된다. 유닉스나 리눅스 계열의 OS에서 사용자의 패스워드 알호화 방법으로 SHA-2 시리즈 중 SHA-512 알고리즘도 사용되고 있다.SHA-1과 SHA-2는 알고리즘의 기본이 비슷하며 이론적으로 해시충돌의 가능성이 있다고 알려져 있으나 그 가능성은 거의 0에 수렴한다.SHA-3은 SHA-1,2와는 전혀 다은 알고리즘을 가지고 있는 새로운 체계의 SHA알고리즘으로 아직까지 결함이 없다고 알려져 있는 해시 알고리즘이다.파이썬은 SHA-2, SHA-3 시리즈의 SHA-256, SHA512 함수를 hashlib 모듈에서 제공한다.from hashlib import sha256, sha512from hashlib import sha3_256, sha3_512SHA-2 시리즈의 SHA-256을 이용하여 “I love Python”의 해시값을 구하는 코드이다.from hashlib import sha256, sha512#from hashlib import sha3_256, sha3_512msg = \"I love Python\"sha = sha256()sha.update(msg.encode('UTF-8'))ret = sha.hexdigest()print(ret)다음과 같은 결과가 출력된다.24e19c4fdadbd5e4670ae6ed98e2e581afe9ecf81e859da25c065404364ace52변수와 모듈의 이름을 sha3_256으로 바꾸면 똑같이 사용가능하다.#from hashlib import sha256, sha512from hashlib import sha3_256, sha3_512msg = \"I love Python\"sha = sha3_256()sha.update(msg.encode('UTF-8'))ret = sha.hexdigest()print(ret)결과. 844887180f047715cb56bd8ed41039e001b329b005049d22c5a7926ac64c6e4f해시의 활용MD5나 SHA외에도 많은 종류의 해시 알고리즘이 있다. 다양한 알고리즘은 여러가지 목적으로 활용되는데, 해시가 대표적으로 활용되는 4가지를 소개한다.해시 인덱스DBMS에서 검색을 위한 인덱스로 해시가 활용되며, DB테이블의 파티셔닝 용도로 사용되기도 한다.해시 인덱스는 검색하고자 하는 값의 해시값을 인덱스로 하는 방법인데, 검색하고자 하는 값을 해시함수에 입력하여 결과로 나오는 해시값과 일치하는 인덱스를 찾고, 해당 레코드 위치를 찾아가는 기법이다.해시 인덱스는 해시의 특성으로 인해 입력한 값과 동일한 값을 검색하는 동등 비교 겁색에서는 탁월한 성능을 발휘하니지만 범위 검색에서는 매우 비효율적이다.패스워드 암호화해시는 사용자 계정의 비밀번호 즉, 패스워드를 암호화하는 방법으로 많이 활용된다.리눅스 계열의 OS는 사용자의 비밀번호를 MD5나 SHA-256, SHA-512 해시값으로 변환하여 보관한다.데이터 무결성 검증해시값은 어떤 데이터의 지문값으로도 불린다. 2개의 데이터가 있을 때 각각의 데이터에 대한 해시값이 일치하면 이 2개읭 데이터는 완전히 동일한 데이터임을 보장할 수 있다. 따라서 어떤 정보의 위조나 변조가 이루어지면 이 정보의 해시값은 원본 데이터의 해시갑소가 완전히 다른값이 된다.해시는 이와 같이 2개의 데이터에 대해 일치성 여부를 검증하는 훌륭한 도로 활용된다.블록체인블록체인 기술은 해시가 광범위하게 활용되고 있다. 블록체인에서는 공개키의 해시값이 은행 계좌번호와 비슷한 용도로 쓰이는데, 이 공개키 해시값을 블록체인 주소라고 부른다.블록체인은 블록이라고 부르는 일련의 거랠르 기록한 데이터 덩어리를 체인 형태의 연결한 구조로 되어 있다.블록을 연결하는 데 활용되는 기술이 해시이며, 이 해시는 각 블록의 무결성 검증에도 활용된다.암호화폐 중 가장 널리 알려진 것이 비트 코인 인데 비트코인은 작업증명(Proof Of Work: POW)이라는 방법을 통해 하나의 블록을 생성하고 이전 블록과 연결시키며 이 과정에서 비트코인이라는 암호화폐를 발행한다. 비트코인이 수행하는 작업증명이라는 과정은 해시 캐시라 부르는 해시 문제풀이를 수행하는 것이다.데이터 무결성 검증하기해시는 2개의 파일 내용의 일치 여부를 확인하는 데 매우 유용하다. 예를 들어, A라는 사람이 어떤 파일을 인터넷을 통해 B라는 사람에게 전달한다. B는 인터넷을 통해 전달받은 파일이 원본 파일과 동일한 것인지를 검증하고 싶다. 이럴 경우 A가 인터넷으로 전송하기 전의 원본 파일에 대한 해시값을 B에게 알려주면 간단히 해결된다.데이터 무결성 검증 알고리즘을 구현해보자컴퓨터의 메모리 크기가 크다면 파일 내용을 한꺼번에 읽어 이에 대한 SHA256 해시를 구하면 되지만, 현실적으로 이는 매우 비효율적인 방법이다.괜찮은 방법은 파일에서 265KB 크기로 정보를 읽어 해시를 업데이트 하는 방법으로 진행하면 된다.다음의 그림은 용량이 큰 파일에 대해 해시값을 구하는 방법을 나타낸 것이다.다음 코드에서 getFileHash(filename)은 인자로 입력된 파일을 위 그림과 같이 256KB씩 읽어 SHA256으로 해시할 데이터를 갱신하고 최종 해시값을 구하는 함수이다.from hashlib import sha256 as SHASIZE = 1024*256 # 256K 정의def getFileHash(filename):    sha = SHA()    h = open(filename, 'rb')    content = h.read(SIZE)  # 파일에서 256KB 만큼 읽어온다.    while content:        sha.update(content) #읽은 256KB 정보만큼 해시할 데이터 갱신        content = h.read(SIZE)  # 파일에서 그 다음 256KB 읽음    h.close()    hashval = sha.digest()  # 최종 해시값 계산    return hashvaldef main():    file1 = \"./plain.txt\"    print(getFileHash(file2))if __name__ == \"__main__\":    main()다음은 두 파일의 무결성을 검증하는 코드이다.from hashlib import sha256 as SHASIZE = 1024*256 # 256K 정의def getFileHash(filename):    sha = SHA()    h = open(filename, 'rb')    content = h.read(SIZE)  # 파일에서 256KB 만큼 읽어온다.    while content:        sha.update(content) #읽은 256KB 정보만큼 해시할 데이터 갱신        content = h.read(SIZE)  # 파일에서 그 다음 256KB 읽음    h.close()    hashval = sha.digest()  # 최종 해시값 계산    return hashvaldef hashCheck(file1, file2):    hashval1 = getFileHash(file1)    hashval2 = getFileHash(file2)    if hashval1 == hashval2:        print(\"Two Files are Same\")    else:        print(\"Two Files are diffrent\")def main():    file1 = \"./plain.txt\"    file2 = \"./plain2.txt\"    hashCheck(file1, file2)if __name__ == \"__main__\":    main()위 코드는 어떤 크기의 파일이라도 두 개의 파일에 대한 무결성 체크를 수행하는 완전한 코드이다.",
            "content_html": "<h2 id=\"해시\">해시</h2><p><strong>해시함수(hash function)</strong>란 임의의 길이를 가진 데이터를 고정된 길이의 데이터로 매핑되는 함수이다. 해시함수의 결과값을 해시값이라고 부른다.</p><p>해시함수는 데이터를 자르거나 치환하거나 위치를 변경하는 방법으로 해시값을 생성하므로, 원본 데이터의 정보를 상실하게 되어 생성된 해시값은 원래 데이터로 복원할 수 없다.</p><p>즉, 해시는 <strong>일방향성</strong>을 가진다.</p><p>해시값은 2개의 다른 입력값에 대해 특정 확률로 동일한 해시값이 나올 수 있다. 이와 같이 서로 다른 입력값에 대해 동일한 해시값이 나오는 상황을 <strong>해시 충돌</strong>이라고 한다.</p><p>해시충돌이 발생하는 특정 확률이라는것이 매우 작은 값이므로 통계적으로 큰 의미가 없다고 볼 수 있다.</p><p>128비트 크기의 해시값을 출력하는 해시함수의 경우, 해시충돌이 발생하는 경우는 1/2^128로 매우 작다. 최근에는 256비트, 512비트 크기의 해시값을 출력하는 해시함수가 사용되기 때문에 해시충돌 발생 확률은 거의 0에 가깝다.</p><p>해시함수에 입력되는 값이 1바이트만 바뀌어도 해시값은 완전히 다른 값으로 출력된다.</p><h2 id=\"md5\">MD5</h2><p>Message-Digest algorithm 5의 약자로 1991년 만들어진 128비트의 길이의 해시값을 출력하는 해시함수이다. MD5는 패스워드의 암호화나 네트워크의 장비인 스위치, 라우터 등에서 장비간 상호 인증을 위해 활용되기도 한다.</p><p>하지만 MD5는 128비트의 다소 작은 크기의 해시값 출력과 알고리즘 자체의 결함도 알려져 있어 최근에는 네트워크로 전송되는 파일의 무결성 검증 등에서만 활용되는 추세이다.</p><p>파이썬에서 MD5해시함수를 사용하려면 파이썬 자체에서 사용하는 hashlib모듈의 md5나 Pycryptodome 모듈에서 제공하는 MD5를 임포트하면 된다.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"nn\">hashlib</span> <span class=\"kn\">import</span> <span class=\"n\">md5</span><span class=\"c1\">#or</span><span class=\"kn\">from</span> <span class=\"nn\">Crypto.Hash</span> <span class=\"kn\">import</span> <span class=\"n\">MD5</span></code></pre></div></div><p>다음은 파이썬의 hashlib 모듈이 제공하는 md5를 이용하여 “I love Python”이라는 메세지에 MD5해시값을 16진수로 출력하는 코드다.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"nn\">hashlib</span> <span class=\"kn\">import</span> <span class=\"n\">md5</span><span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s\">\"I love Python\"</span><span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">md5</span><span class=\"p\">()</span><span class=\"n\">m</span><span class=\"p\">.</span><span class=\"n\">update</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"p\">.</span><span class=\"n\">encode</span><span class=\"p\">(</span><span class=\"s\">'UTF-8'</span><span class=\"p\">))</span><span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">m</span><span class=\"p\">.</span><span class=\"n\">hexdigest</span><span class=\"p\">()</span><span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">ret</span><span class=\"p\">)</span></code></pre></div></div><p>“I love Python”에 대한 MD5 해시값은 16진수로 다음과 같다.</p><p><code class=\"language-plaintext highlighter-rouge\">27eb2f69c24aa5f3503a6ae610f23a83</code></p><h2 id=\"sha\">SHA</h2><p>Secure Hash Algorithm의 약자로 1993년 미국의 NSA가 만들고 미국 국립표준기술연구소에서 표준으로 제정된 해시함수이다. SHA는 SHA-0, SHA-1, SHA-2, SHA-3로 발전되어 왔다. 토렌트로 잘 알려진 P2P 파일 공유 시스템의 원조격인 비트토렌트에서 파일의 무경성이나 인덱싱을 위해 SHA-1 알고리즘이 활용되었고, 패스워드 암호화나 블록체인 등에서는 SHA-2 시리즈 중 SHA-256 알고리즘이 광법위하게 사용된다. 유닉스나 리눅스 계열의 OS에서 사용자의 패스워드 알호화 방법으로 SHA-2 시리즈 중 SHA-512 알고리즘도 사용되고 있다.</p><p>SHA-1과 SHA-2는 알고리즘의 기본이 비슷하며 이론적으로 해시충돌의 가능성이 있다고 알려져 있으나 그 가능성은 거의 0에 수렴한다.</p><p>SHA-3은 SHA-1,2와는 전혀 다은 알고리즘을 가지고 있는 새로운 체계의 SHA알고리즘으로 아직까지 결함이 없다고 알려져 있는 해시 알고리즘이다.</p><p>파이썬은 SHA-2, SHA-3 시리즈의 SHA-256, SHA512 함수를 hashlib 모듈에서 제공한다.</p><div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>from hashlib import sha256, sha512from hashlib import sha3_256, sha3_512</code></pre></div></div><p>SHA-2 시리즈의 SHA-256을 이용하여 “I love Python”의 해시값을 구하는 코드이다.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"nn\">hashlib</span> <span class=\"kn\">import</span> <span class=\"n\">sha256</span><span class=\"p\">,</span> <span class=\"n\">sha512</span><span class=\"c1\">#from hashlib import sha3_256, sha3_512</span><span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s\">\"I love Python\"</span><span class=\"n\">sha</span> <span class=\"o\">=</span> <span class=\"n\">sha256</span><span class=\"p\">()</span><span class=\"n\">sha</span><span class=\"p\">.</span><span class=\"n\">update</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"p\">.</span><span class=\"n\">encode</span><span class=\"p\">(</span><span class=\"s\">'UTF-8'</span><span class=\"p\">))</span><span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">sha</span><span class=\"p\">.</span><span class=\"n\">hexdigest</span><span class=\"p\">()</span><span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">ret</span><span class=\"p\">)</span></code></pre></div></div><p>다음과 같은 결과가 출력된다.</p><p><code class=\"language-plaintext highlighter-rouge\">24e19c4fdadbd5e4670ae6ed98e2e581afe9ecf81e859da25c065404364ace52</code></p><p>변수와 모듈의 이름을 sha3_256으로 바꾸면 똑같이 사용가능하다.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">#from hashlib import sha256, sha512</span><span class=\"kn\">from</span> <span class=\"nn\">hashlib</span> <span class=\"kn\">import</span> <span class=\"n\">sha3_256</span><span class=\"p\">,</span> <span class=\"n\">sha3_512</span><span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s\">\"I love Python\"</span><span class=\"n\">sha</span> <span class=\"o\">=</span> <span class=\"n\">sha3_256</span><span class=\"p\">()</span><span class=\"n\">sha</span><span class=\"p\">.</span><span class=\"n\">update</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"p\">.</span><span class=\"n\">encode</span><span class=\"p\">(</span><span class=\"s\">'UTF-8'</span><span class=\"p\">))</span><span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">sha</span><span class=\"p\">.</span><span class=\"n\">hexdigest</span><span class=\"p\">()</span><span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">ret</span><span class=\"p\">)</span></code></pre></div></div><p>결과. <code class=\"language-plaintext highlighter-rouge\">844887180f047715cb56bd8ed41039e001b329b005049d22c5a7926ac64c6e4f</code></p><h2 id=\"해시의-활용\">해시의 활용</h2><p>MD5나 SHA외에도 많은 종류의 해시 알고리즘이 있다. 다양한 알고리즘은 여러가지 목적으로 활용되는데, 해시가 대표적으로 활용되는 4가지를 소개한다.</p><h3 id=\"해시-인덱스\">해시 인덱스</h3><p>DBMS에서 검색을 위한 인덱스로 해시가 활용되며, DB테이블의 파티셔닝 용도로 사용되기도 한다.해시 인덱스는 검색하고자 하는 값의 해시값을 인덱스로 하는 방법인데, 검색하고자 하는 값을 해시함수에 입력하여 결과로 나오는 해시값과 일치하는 인덱스를 찾고, 해당 레코드 위치를 찾아가는 기법이다.</p><p>해시 인덱스는 해시의 특성으로 인해 입력한 값과 동일한 값을 검색하는 동등 비교 겁색에서는 탁월한 성능을 발휘하니지만 범위 검색에서는 매우 비효율적이다.</p><h3 id=\"패스워드-암호화\">패스워드 암호화</h3><p>해시는 사용자 계정의 비밀번호 즉, 패스워드를 암호화하는 방법으로 많이 활용된다.리눅스 계열의 OS는 사용자의 비밀번호를 MD5나 SHA-256, SHA-512 해시값으로 변환하여 보관한다.</p><h3 id=\"데이터-무결성-검증\">데이터 무결성 검증</h3><p>해시값은 어떤 데이터의 지문값으로도 불린다. 2개의 데이터가 있을 때 각각의 데이터에 대한 해시값이 일치하면 이 2개읭 데이터는 완전히 동일한 데이터임을 보장할 수 있다. 따라서 어떤 정보의 위조나 변조가 이루어지면 이 정보의 해시값은 원본 데이터의 해시갑소가 완전히 다른값이 된다.해시는 이와 같이 2개의 데이터에 대해 일치성 여부를 검증하는 훌륭한 도로 활용된다.</p><h3 id=\"블록체인\">블록체인</h3><p>블록체인 기술은 해시가 광범위하게 활용되고 있다. 블록체인에서는 공개키의 해시값이 은행 계좌번호와 비슷한 용도로 쓰이는데, 이 공개키 해시값을 블록체인 주소라고 부른다.블록체인은 블록이라고 부르는 일련의 거랠르 기록한 데이터 덩어리를 체인 형태의 연결한 구조로 되어 있다.블록을 연결하는 데 활용되는 기술이 해시이며, 이 해시는 각 블록의 무결성 검증에도 활용된다.</p><p>암호화폐 중 가장 널리 알려진 것이 비트 코인 인데 비트코인은 작업증명(Proof Of Work: POW)이라는 방법을 통해 하나의 블록을 생성하고 이전 블록과 연결시키며 이 과정에서 비트코인이라는 암호화폐를 발행한다. 비트코인이 수행하는 작업증명이라는 과정은 해시 캐시라 부르는 해시 문제풀이를 수행하는 것이다.</p><h2 id=\"데이터-무결성-검증하기\">데이터 무결성 검증하기</h2><p>해시는 2개의 파일 내용의 일치 여부를 확인하는 데 매우 유용하다. 예를 들어, A라는 사람이 어떤 파일을 인터넷을 통해 B라는 사람에게 전달한다. B는 인터넷을 통해 전달받은 파일이 원본 파일과 동일한 것인지를 검증하고 싶다. 이럴 경우 A가 인터넷으로 전송하기 전의 원본 파일에 대한 해시값을 B에게 알려주면 간단히 해결된다.</p><p>데이터 무결성 검증 알고리즘을 구현해보자</p><p>컴퓨터의 메모리 크기가 크다면 파일 내용을 한꺼번에 읽어 이에 대한 SHA256 해시를 구하면 되지만, 현실적으로 이는 매우 비효율적인 방법이다.괜찮은 방법은 파일에서 265KB 크기로 정보를 읽어 해시를 업데이트 하는 방법으로 진행하면 된다.</p><p>다음의 그림은 용량이 큰 파일에 대해 해시값을 구하는 방법을 나타낸 것이다.</p><p><img src=\"https://0o3q.github.io/images/2023-04-12-hash/how_hash_value.png\" alt=\"Image how_hash_value\" /></p><p>다음 코드에서 getFileHash(filename)은 인자로 입력된 파일을 위 그림과 같이 256KB씩 읽어 SHA256으로 해시할 데이터를 갱신하고 최종 해시값을 구하는 함수이다.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"nn\">hashlib</span> <span class=\"kn\">import</span> <span class=\"n\">sha256</span> <span class=\"k\">as</span> <span class=\"n\">SHA</span><span class=\"n\">SIZE</span> <span class=\"o\">=</span> <span class=\"mi\">1024</span><span class=\"o\">*</span><span class=\"mi\">256</span> <span class=\"c1\"># 256K 정의</span><span class=\"k\">def</span> <span class=\"nf\">getFileHash</span><span class=\"p\">(</span><span class=\"n\">filename</span><span class=\"p\">):</span>    <span class=\"n\">sha</span> <span class=\"o\">=</span> <span class=\"n\">SHA</span><span class=\"p\">()</span>    <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"n\">filename</span><span class=\"p\">,</span> <span class=\"s\">'rb'</span><span class=\"p\">)</span>    <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">h</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">SIZE</span><span class=\"p\">)</span>  <span class=\"c1\"># 파일에서 256KB 만큼 읽어온다.</span>    <span class=\"k\">while</span> <span class=\"n\">content</span><span class=\"p\">:</span>        <span class=\"n\">sha</span><span class=\"p\">.</span><span class=\"n\">update</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span> <span class=\"c1\">#읽은 256KB 정보만큼 해시할 데이터 갱신</span>        <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">h</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">SIZE</span><span class=\"p\">)</span>  <span class=\"c1\"># 파일에서 그 다음 256KB 읽음</span>    <span class=\"n\">h</span><span class=\"p\">.</span><span class=\"n\">close</span><span class=\"p\">()</span>    <span class=\"n\">hashval</span> <span class=\"o\">=</span> <span class=\"n\">sha</span><span class=\"p\">.</span><span class=\"n\">digest</span><span class=\"p\">()</span>  <span class=\"c1\"># 최종 해시값 계산</span>    <span class=\"k\">return</span> <span class=\"n\">hashval</span><span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>    <span class=\"n\">file1</span> <span class=\"o\">=</span> <span class=\"s\">\"./plain.txt\"</span>    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">getFileHash</span><span class=\"p\">(</span><span class=\"n\">file2</span><span class=\"p\">))</span><span class=\"k\">if</span> <span class=\"n\">__name__</span> <span class=\"o\">==</span> <span class=\"s\">\"__main__\"</span><span class=\"p\">:</span>    <span class=\"n\">main</span><span class=\"p\">()</span></code></pre></div></div><p>다음은 두 파일의 무결성을 검증하는 코드이다.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"nn\">hashlib</span> <span class=\"kn\">import</span> <span class=\"n\">sha256</span> <span class=\"k\">as</span> <span class=\"n\">SHA</span><span class=\"n\">SIZE</span> <span class=\"o\">=</span> <span class=\"mi\">1024</span><span class=\"o\">*</span><span class=\"mi\">256</span> <span class=\"c1\"># 256K 정의</span><span class=\"k\">def</span> <span class=\"nf\">getFileHash</span><span class=\"p\">(</span><span class=\"n\">filename</span><span class=\"p\">):</span>    <span class=\"n\">sha</span> <span class=\"o\">=</span> <span class=\"n\">SHA</span><span class=\"p\">()</span>    <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"n\">filename</span><span class=\"p\">,</span> <span class=\"s\">'rb'</span><span class=\"p\">)</span>    <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">h</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">SIZE</span><span class=\"p\">)</span>  <span class=\"c1\"># 파일에서 256KB 만큼 읽어온다.</span>    <span class=\"k\">while</span> <span class=\"n\">content</span><span class=\"p\">:</span>        <span class=\"n\">sha</span><span class=\"p\">.</span><span class=\"n\">update</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span> <span class=\"c1\">#읽은 256KB 정보만큼 해시할 데이터 갱신</span>        <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">h</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">SIZE</span><span class=\"p\">)</span>  <span class=\"c1\"># 파일에서 그 다음 256KB 읽음</span>    <span class=\"n\">h</span><span class=\"p\">.</span><span class=\"n\">close</span><span class=\"p\">()</span>    <span class=\"n\">hashval</span> <span class=\"o\">=</span> <span class=\"n\">sha</span><span class=\"p\">.</span><span class=\"n\">digest</span><span class=\"p\">()</span>  <span class=\"c1\"># 최종 해시값 계산</span>    <span class=\"k\">return</span> <span class=\"n\">hashval</span><span class=\"k\">def</span> <span class=\"nf\">hashCheck</span><span class=\"p\">(</span><span class=\"n\">file1</span><span class=\"p\">,</span> <span class=\"n\">file2</span><span class=\"p\">):</span>    <span class=\"n\">hashval1</span> <span class=\"o\">=</span> <span class=\"n\">getFileHash</span><span class=\"p\">(</span><span class=\"n\">file1</span><span class=\"p\">)</span>    <span class=\"n\">hashval2</span> <span class=\"o\">=</span> <span class=\"n\">getFileHash</span><span class=\"p\">(</span><span class=\"n\">file2</span><span class=\"p\">)</span>    <span class=\"k\">if</span> <span class=\"n\">hashval1</span> <span class=\"o\">==</span> <span class=\"n\">hashval2</span><span class=\"p\">:</span>        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"Two Files are Same\"</span><span class=\"p\">)</span>    <span class=\"k\">else</span><span class=\"p\">:</span>        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"Two Files are diffrent\"</span><span class=\"p\">)</span><span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>    <span class=\"n\">file1</span> <span class=\"o\">=</span> <span class=\"s\">\"./plain.txt\"</span>    <span class=\"n\">file2</span> <span class=\"o\">=</span> <span class=\"s\">\"./plain2.txt\"</span>    <span class=\"n\">hashCheck</span><span class=\"p\">(</span><span class=\"n\">file1</span><span class=\"p\">,</span> <span class=\"n\">file2</span><span class=\"p\">)</span><span class=\"k\">if</span> <span class=\"n\">__name__</span> <span class=\"o\">==</span> <span class=\"s\">\"__main__\"</span><span class=\"p\">:</span>    <span class=\"n\">main</span><span class=\"p\">()</span></code></pre></div></div><p>위 코드는 어떤 크기의 파일이라도 두 개의 파일에 대한 무결성 체크를 수행하는 완전한 코드이다.</p>",
            "url": "https://0o3q.github.io/2023/04/12/hash",
            
            
            
            
            
            "date_published": "2023-04-12T00:00:00+09:00",
            "date_modified": "2023-04-12T00:00:00+09:00",
            
                "author":  {
                "name": "0o3q",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://0o3q.github.io/2023/04/12/blockchain-with-bitcoin",
            "title": "블록체인과 비트코인",
            "summary": null,
            "content_text": "블록체인의 개념과 구조블록체인은 단어 그대로 해석해보면 블록이 서로 연결되어 있다라는 의미이다. 여기서 블록이란 거래(or 트랜잭션) 기록을 담고있는 장부의 한 페이지라고 생각하면 이해가 쉽다.즉 블록에는 거래 당사자들의 모든 거래 내용을 담고 있으며 일정한 조건을 만족하면 하나의 블록을 완성시키고 다음 블록에 새로운 거래 내용을 기록하게 된다. 여기서 일정한 조건이란 나중에 설명할 블록 생성을 위한 합의 알고리즘이다.다음 블록에는 이전 블록들의 모든 정보를 압축하여 담아 두는데, 이를 위해 SHA-256해시를 활용한다.이러한 블록들은 거래가 참여하는 모든 당사자들에게 공유됨으로써 거래에 대한 투명성을 높이고 이전 블록들의 압축된 정보를 다음 블록에 기록함으로써 위조나 변조가 매우 힘들도록 한 것이다.블록체인을 한 문장으로 정의하면 다음과 같이 요약할 수 있다.“블록”이라고 하는 거래 기록을 담고있는 데이터들이 거래 참여자들의 합의에 생선된 체인 형태의 연결고리를 가진 형태로 구성되어 모든 거래 참여자들에 배포되며, 누구나 기록된 거래 내용의 결과를 열람할 수 있지만, 어느 누구도 임의로 수정할 수 없도록 만든 분산 컴퓨팅 기반의 데이터 위변조 방지 기술이다.블록체인은 일반적으로 다음과 같은 구조를 띈다.블록체인은 블록 1에서부터 거래를 기록하게 되며 특정한 조건인 합의 알고리즘을 통해 블록 1에 더이상 거래를 기록할 수 없도록 블록을 동결하고 완성시킨다.블록 1에 기록된 정보를 대표하는 해시값 Hash1을 생성하고 Hash1은 다음 블록인 블록 2에 기록한다. 블록 2도 특정한 조건에 만족하면 블록 1과 같은 과정으로 거치고 그 다음 블록인 블록 3에 거래를 기록하는 방식으로 진행된다. 이런식으로 구성되는 블록체인은 거래에 참여하는 모든 당사자들에게 배포된다.블록체인에서 첫 번째 블록인 블록 1을 “제네시스 블록”이라 부르고 이 블록의 정보가 거짓이라면 블록체인의 전체 정보가 거짓이 되기 때문에 제네시스 블록에는 반드시 참 값을 기록해야 한다.블록체인을 구성하는 블록의 일반적인 구조는 다음과 같다.블록은 블록헤더(block header)와 블록몸체(block body)로 이루어져 있다. 블록몸체에는 거래를 기록하며, 블록헤더에는 이전 블록헤더의 해시값, 현재 블록에 기록되어 있는 전체 거래에 대한 해시값 그리고 기타 정보들이 기록되어 있다. 블록헤더의 기타 정보 부분은 블록체인의 종류에 따라 기록되는 데이터가 다르다.블록헤더에 기록되어 있는 해시값은 모두 SHA-256을 이용한다. 블록헤더에 기록된 현 블록의 전체 트랜잭션에 대한 해시값은 머클트리(Merkle Tree)라는 방법으로 계산되는데, 그림에서 보는 것처럼 피라미드구조와 같이 2개의 트랜잭션에 대한 해시값을 짝지어 이 2개의 해시값에 대한 해시값을 계산하는 방법으로 피라미드 꼭대기에 있는 1개의 해시값으로 만드는 것이다.피라미드 꼭대기에 있는 해시값을 머클루트(Merkle Root)라 부르며, 이 머클루트가 블록헤더의 전체 트랜잭션 해시값이 되는 것이다.따라서 블록헤더에는 현재 블록의 전체 거래 기록들의 압축된 정보가 기록되어 있는 셈이다.이 블록헤더에 대한 해시값은 나중에 다음 블록의 블록헤더에 이전 블록 해시값 부분에 기록된다.물론 블록헤더에 기록되는 머클루트는 블록이 완성되기까지 거래기록이 추가되면 계속 변하는 값이다. 다음 블록에 기록할 현재 블록헤더에 대한 해시값은 블록에 더 이상 거래를 기록할 수 없도록 한 상태에서 만들어진다.블록몸체에 기록되는 거래 즉 트랜잭션 데이터는 거래 정보와 부가 데이터를 저장할 수 있는 공간으로 되어있다.지금까지 설명한 블록체인의 구조는 블록체인의 종류에 상관없이 거의 공통적인 내용이며, 블록이 만들어지는 조건인 합의 알고리즘이나 블록의 크기등이 블록체인의 종류에 따라 달라진다.블록체인과 작업증명블록체인에선 블록은 거래 참여자들의 합의에 의해 생성되고 배표된다고 언급했다. 합의 알고리즘은 분산 네트워크 상에 존재하는 서로 신뢰할 수 없는 정보들에 대해 수학적으로 계산된 값을 특정 절차에 따라 상호 검증하여 신뢰 가능하도록 보장하는 알고리즘이다.블록체인의 연결 구조와 합의 알고리즘이라는 메커니즘을 통해 블록체인에 담긴 정보들의 위조나 변조가 매우 어려워진다.블록체인에서 활용되는 합의 알고리즘은 다양하게 존재하는데 대표적으로 작업증명(Proof Of Work), 지분증명(Proof Of Stake), PBFT(Practical Byzantine Fault Tolerance), RAFT 등이 있다.우선 해시와 매우 밀접한 작업 증명에 대해서만 알아본다.작업증명은 주어진 해시값보다 작아지도록 SHA-256에 입력되는 값을 찾아내는 것이다.작업증명의 난이도는 주어진 해시값에 따라 달라진다.문제 1SHA-256(value) ≤ 000c007…3c240b36c312위 문제 1을 만족하는 value를 찾아낸느 것이 작업증명의 메커니즙이다. 작업증명을 더 쉽게 이해할 수 있도록 다음의 문제를 생각해보자“Attack at 9PM!”이라는 문자에 대한 SHA-256해시값은 다음과 같다.SHA-256(”Attack at 9PM!”) = c53ae0b1db6f94ce4177112…9f5a19f47d473a785dc97afc이제 “Attack at 9PM!” 문장 뒤에 숫자 0을 더해서 SHA-256 해시값을 계산해보면 다음과 같은 결과가 나온다.SHA-256(”Attack at 9PM!0”) = 8eb6977a7765fda7cf7d6…20ede2b3c371ab6c9adc41a0여기서 문제를 제시한다.문제 2“Attack at 9PM!”에 어떤 숫자를 추가하여 구한 SHA-256 해시값이 00으로 시작되도록하는 어떤 숫자를 구하라문제 2를 풀기 위해서는 “Attack at 9PM!”에 0을 추가하여 SHA-256 해시값을 구하고 을 추가하여 SHA-256 해시값을 구하는식으로 부르트포싱하여 구한 해시값이 00으로 시작되는 그 숫자를 찾으면 된다.가장 최초로 나타나는 값은 240이다.문제 2와 같은 유형의 문제를 해시캐시(hashcash)라고 부른다. 해시캐시 문제의 답을 구하려면 그냥 무식하게 부르트포싱하는 방법뿐이다. 부르트포싱하며 원래 메세지에 추가하는 값을 nounce라고 한다. 즉 해시캐시 문제는 주어진 해시값고 같아지는 nounce 값을 찾는 것이다.문제 2에서 주어진 문제가 00으로 시작하는게 아닌 000으로 시작하는 해시값이면 난이도는 더욱 올라가고 nounce는 6541이 된다. 따라서 0의 개수가 많아질 수록 해시캐시 문제의 난이도는 증가한다.작업증명은 해시캐시 문제를 푸는 원리와 동일하다다음은 문장 “Attack at 9PM!”에 대한 해시캐시를 구하는 파이썬 코드이다.from hashlib import sha256 as shadef hashcash(msg, difficulty):    nounce = 0    print(\"+++ Start\")    while True:        target = \"%s%d\" %(msg, nounce)        ret = sha(target.encode()).hexdigest()        if ret[:difficulty] == '0'*difficulty:            print(\"++++ Bingo\")            print(\"---&gt;\", ret)            print(\"---&gt; NOUNCE = %d\" %nounce)            break        nounce += 1def main():    msg = \"Attack at 9PM!\"    difficulty = 1    hashcash(msg, difficulty)if __name__ == \"__main__\":    main()difficulty의 개수에 따라 0의 개수가 정해지며 difficulty가 커지면 시간도 그에 맞게 커진다.비트코인에서 사용되는 작업증명은 비트코인의 작업증명에서 자세히 다룬다.작업증명의 효과앞에서 제시한 해시캐시는 난이도가 매우 낮아서 일반 PC 1대로도 순식간에 nounce를 구할 수 있다.하지만 비트코인이나 이더리움같은 블록체인 네트워크에서는 네크워크에 참여하는 모든 노드(실제로는 블록을 생성하기 위해 참여한 노드)의컴퓨팅 파워를 총 동원하여 일정한 시간동안 계산해야만 nounce를 구할 수 있을 정도로 해시캐시 난이도를 조정한다.비트코인의 경우 참여하는 모든 노드의 컴퓨팅 파워를 동원하여 10분 정도 걸리는 해시캐시 난이도로 설정한다.실제 작업증명의 메커니즘은 다음과 같다.  거래 정보가 담긴 1번 블록의 정보를 이용해 해시캐시 문제를 제시한다.  제시된 해시캐시 문제는 블록체인에 참여한 모든 노드의 컴퓨팅 파워로 10분정도 걸려야 풀 수 있는 난이도로 설정되어 있다.  특정 노드에서 해시캐시 문제의 답을 구했다면 1번 블록에 정답을 기록하고 더 이상의 거래 기록을 담지 못하게 동결하고 이 블록을 모든 참여 노드에 전달한다.  해시캐시 문제의 정답을 구하는 것은 어렵지만 답을 구하면 그 답이 정답인지 검증하는 것은 매우 쉽다. 따라서 블록을 전달받은 모든 블록에 포함된 해시캐시 정답을 검증하고 정말 정답이면 블록을 수용하고 그렇지 않으면 블록을 폐기한다.  새로운 2번 블록에 거래를 기록한다.  2번 이후 블록에 대해 1~5 과정을 반복한다.이제 다음과 같은 상황을 가정한다.100개의 노드(각 노드는 동일한 컴퓨팅 파워를 가지고 있다고 가정한다.)가 블록체인 네트워크에 참여하고 있고, 현재 n번째 블록까지 생성된 상태이다. 100개의 노드 중 10개의 노드가 n+1번째 블록의 거래 내용을 조작한다고 할 때, 작업증명의 효과로 다음과 같은 상황이 된다.  조작된 n+1번째 블록 내용을 기반으로 100개의 노드가 10분간 풀어야할 해시캐시 문제를 10개 노드가 해결해야한다.  그동안 정상적인 n+1번째 블록 내용을 기반으로 100개의 노드가 10분간 풀어야할 해시캐시 문제를 90개의 노드가 해결하고 있는 중이다.  확률적으로 정상적인 n+1번째 블록에 대한 해시캐시 문제가 훨씬 빨리 해결될 것이고, n+1번째 블록을 생성한 후 n+2번째 블록에 대한 해시캐시 문제를 90개의 노드가 해결하고 있는 상황이 된다.  이제 10개의 노드는 n+1번째 블록뿐만 아니라 n+2번째의 블록에 대한 해시캐시 문제를 해결해야 되는 지경에 이른다.이런 원리를 통해 10개의 노드는 블록의 내용을 위변조하는 것은 거의 불가능에 가깝게 된다.따라서 블록체인에서 작업증명의 효과는 블록체인 구조에서 기인되는 위변조 조작의 어려움에 더해 더욱 위변조가 어려워지도록 하는 효과를 가진다.이럼에도 불구라고 1개의 노드가 조작된 블록에 해시캐시 문제를 해결하고 모든 노드에 배표하게 된다면, 조작된 블로깅 포함된 브록체인의 기링가 정상적인 블록체인의 길이보다 짧을 것이다.블록체인 시스템은 2개이상의 블록체인이 배포될때 길이가 딘 블록체인의 채캑을 원칙으로 하고 있다.비트코인의 블록구조비트코인은 브록체인 기술을 활용한 최초의 분산원장 기술이자 가장 잘 알려진 암호화폐 시스템이다. 비트코인을 기본적으로 이해하고 있다면 다른 블록체인 시스템에 대해 보다 쉽게 접근할 수 있다.비트코인의 즐록 구조는 블록체인의 일반적인 구종와 동일하다. 실제 비트코인의 블록에는 다음의 그림과 같은 정보들로 구성되어 있다.위 그림처럼 매직넘버와 블록 크기를 나타내는 필드를 제외하면 비트코인 블록은 블록헤더와 블록몸체로 구성되어 있는 것을 볼 수 있다. 블록헤더는 총 6개의 필드로 구성되어 있고, 블록몸체에는 거래 개수와 거래 정보가 담겨있다.블록 몸체를 이루는 값들에 대해 간단히 살펴보면 Trancsaction counter는 블록몸체에 기록된 거래 개수이다. 거래 정보가 블록봅체에 추가될 때마다 Transaction counter는 1증가한다.블록몸체에서 Coinbase transaction은 새로운 블록이 생성될 때 블록몸체에 최초로 기록되는 거래 정보로. 생성 거래로 부르기도 하며 초기에는 무의미한 값들로 구성되어 있다. 하지만 작업증명이 성공하게 되면 새로 발행되는 비트코인을 성공한 노드의 비트코인 주소로 입금하는 거래 정보로 변경된다.블록헤더의 6개 필드 중 첫 3개는 앞에서 설명했으니 Time 필드부터 살펴본다.Time 필드는 현재 시간을 기록하는 타임스탬프 역할을 하는데, 이 값은 몇 초마다 갱신되며 블록이 완성될 때까지 지속적으로 변한다.Bits는 작업증명을 위한 대상값(Target)을 저장하는 부분인데 실제로는 Bits에 저장된 값을 특정 공식에 적용하여 대상값을 산출해내며, 이 대상값보다 블록헤더의 해시값이 작아지게 되는 nounce를 구하면 작업증명에 성공하게 된다. 이에 대해서는 실제 비트코인 블록헤더를 이용하여 작업증명 메커니즘을 설명할 때 알아본다.Bits는 비트코인 네트워크에 참여하고 있는 노드의 수에 따라 값이 변하는데, 앞에서 설명한 바와 같이 모든 참여자 노드의 컴퓨팅 파워를 이용해 해시캐시 문제를 10분 정도 걸려야 풀 수 있도록 조정된다.다음은 실제 비트코인의 125,552번째 블록헤더의 내용이다.위 그림에서 각 필드의 값들은 모두 리클 엔디안 방식으로 메모리에 저장되어 있는 값을 보여주고 있다.인텔 x86 계열의 CPU는 리틀 엔디안 방식으로 메모리에 데이터를 저장한다.리틀 엔디안이란 하뉘 주소의 메모리에 낮은 자리의 숫자를 기록하는 방식이다.16진수 0x1b0404cb를 리틀 엔디안으로 메모리에 저장하면 다음과 같다.따라서 실제 위 그림의 블록헤더에 저장되어 있는 Bits의 값은 0x1a449b2f, Nounce의 값은 0x9546a142이다.비트코인의 작업증명비트코인의 작업증명은 블록헤더 6개 필드에 대한 해시캐시를 구하는 문제이다. 해시캐시의 난이도는 Bits 필드에 저장된 Target값으로 결정된다.비트코인 작업증명SHA-256(블록헤더 6개 필드) ≤ TargetTargt값은 Bits에 저장된 값을 특정 변환 공식을 적용하여 얻어진다.비트코인의 난이도 설정값인 4바이트 크기의 Bits를 Target값으로 변환하는 공식은 다음과 같다.Bits의 값이 0x1a44b9f2인 경우,  Bits의 앞 2자리와 쥐 6자리를 다음과 같이 분리함  1a 44b9f2  Target = 0x44b9f2 * 2*(8(0x1a-3))다음은 리틀 엔디안 으로 저장된 Bits를 Target으로 변환하는 파이썬 코드다.from hashlib import sha256 as shaimport codecs#인자 bits를 실제 16진수 값으로 리턴def decodeBitcoinVal(bits):    decode_hex = codecs.getdecoder('hex_codec')    binn = decode_hex(bits)[0]    ret = codecs.encode(binn[::-1], 'hex_codec')    return retdef getTarget(bits):    bits = decodeBitcoinVal(bits)    bits = int(bits, 16)    print(\"Bits = %x\" %bits)    bit1 = bits &gt;&gt; 4*6    base = bits &amp; 0x00ffffff    sft = (bit1 - 0x3)*8    target = base &lt;&lt; sft    print(\"Target = %x\" %target)Bits = \"f2b9441a\"getTarget(Bits)실제 비트코인의 125,552번째의 Bits값 사용def decodeBitcoinVal(bits):    decode_hex = codecs.getdecoder('hex_codec')    binn = decode_hex(bits)[0]    ret = codecs.encode(binn[::-1], 'hex_codec')    return ret위 코드에서 리틀 엔디안으로 표현된 16진수값을 받아와 실제 16진수 순서로 변환한 후 정수 값으로 리턴한다.def getTarget(bits):    bits = decodeBitcoinVal(bits)    bits = int(bits, 16)    print(\"Bits = %x\" %bits)    bit1 = bits &gt;&gt; 4*6    base = bits &amp; 0x00ffffff    sft = (bit1 - 0x3)*8    target = base &lt;&lt; sft    print(\"Target = %x\" %target)Bits를 Target값으로 변환하는 공식 구현1비트를 오른쪽으로 쉬프트하면 원래의 값에 2를 곱한 것과 동일하다. 반대로 1비트를 왼쪽으로 쉬프트하면 2를 나눈 것과 동일하다.16진수는 4비트로 표현되므로 A»4와 A«4는 각각 원래의 값 A에 대해 16진수 자리수를 한자리 내리거나 또는 한자리 올린다는 의미와 같다.코드를 실행하면 Target이 다음과 같이 출력된다.Target = 44b9f20000000000000000000000000000000000000000000000비트코인에서 Target은 해시캐시 문제를 풀기 위한 대상이라고 했다. 비트코인 블록헤더에 기록된 6개 필드에 대한 SHA-256 해시값이 이 값보다 작게 되는 nounce값을 찾는 것이다.SHA-256 해시는 32바이트로 표현되므로, 위 Target을 32바이트로 표현하면 다음과 같은 값이 된다.Target = 00000000000044b9f20000000000000000000000000000000000000000000000따라서 다음의 식을 만족하는 Nounce 값을 계산해야 비트코인의 125.552번째 블록이 완성된다.SHA-256(Version+HashPrevBlock+HashMerkleRoot+Time+Bits+Nounce) ≤ 00000000000044b9f20000000000000000000000000000000000000000000000다음 코드는 비트코인의 125,532번째 블록에 대해 Nounce값을 검증하는 코드이다. 비트코인의 125,532번째 블록은 이미 오래전에 만들어진 블록이므로 기록된 Nounce값이 위 해시캐시 문제를 만족하는 값일 것이다from hashlib import sha256 as shaimport codecs#인자 bits를 실제 16진수 값으로 리턴def decodeBitcoinVal(bits):    decode_hex = codecs.getdecoder('hex_codec')    binn = decode_hex(bits)[0]    ret = codecs.encode(binn[::-1], 'hex_codec')    return retdef getTarget(bits):    bits = decodeBitcoinVal(bits)    bits = int(bits, 16)    bit1 = bits &gt;&gt; 4*6    base = bits &amp; 0x00ffffff    sft = (bit1 - 0x3)*8    target = base &lt;&lt; sft    return target# 아래에는 2011년 5월에 생성된 비트코인 125,552번째 블록에 대한 작업 증명이 성공했음을 검증하는 코드이다.def validatePoW(header):    block_version = header[0]    hashPrecBlock = header[1]    hashMerkleRoot = header[2]    Time = header[3]    Bits = header[4]    nounce = header[5]    #블록 헤더의 모든 값을 더하고 이름 바이트 객체로 변경    decode_hex = codecs.getdecoder('hex_codec')    header_hex = block_version+hashPrecBlock+hashMerkleRoot+Time+Bits+nounce    header_bin = decode_hex(header_hex)[0]    # 실제 비트코인에서는 블록헤더의 SHA-256 해시에 대한 SHA256해시를 이용해서 작업증명을 한다.    hash = sha(header_bin).digest()    hash = sha(hash).digest()    PoW = codecs.encode(hash[::-1], 'hex_codec')    #헤더의 Bits 값을 이요해 실제 target 값 추출    target = getTarget(Bits)    target = str(hex(target))    target = '0'*(66-len(target)) + target[2:]    print(\"target\\t=\", target)    print(\"BlockHash\\t=\", PoW.decode())    # 작업 증명이 성공한 건지 체크    if int(PoW, 16) &lt;= int(target, 16):        print(\"+++ Accept this Block\")    else:        print(\"--- Reject this Block\")def main():    block_version = \"01000000\"    hashPrevBlock = \"81cd02ab7e569e8bcd9317e2fe99f2de44d49ab2b8851ba4a308000000000000\"    hashMerkleRoot = \"e320b6c2fffc8d750423db8b1eb942ae710e951ed797f7affc8892b0f1fc122b\"    Time = \"c7f5d74d\"    Bits = \"f2b9441a\"    nounce = \"42a14695\"    header = [block_version, hashPrevBlock, hashMerkleRoot, Time, Bits, nounce]    validatePoW(header)main()실행 결과target  = 00000000000044b9f20000000000000000000000000000000000000000000000BlockHash       = 00000000000000001e8d6829a8a21adc5d38d0a473b144b6765798e61f98bd1d+++ Accept this Block비트코인 블록 검색 사이트 아무거나 들어가면 일치하는 것을 볼 수 있다.import codecs#인자 bits를 실제 16진수 값으로 리턴def changeEndian(bits):    decode_hex = codecs.getdecoder('hex_codec')    binn = decode_hex(bits)[0]    ret = codecs.encode(binn[::-1], 'hex_codec')    print(ret)Bits = \"2b12fcf1b09288fcaff797d71e950e71ae42b91e8bdb2304758dfcffc2b620e3\"changeEndian(Bits)쓸모 있을 지 모르지만 엔디안 바꾸는 코드이다.비트코인 주소 생성하기모든 블록체인 시스템은 은행계좌번호와 비슷한 역할을 하는 블록체인 주소라는 것이 있는데, 비트코인에서 이 주소를 비트코인 주소라고 부른다.A라는 사람이 B라는 사람에게 비트코인을 전송하려면, A의 비트코인 주소에 담겨있는 비트코인을 B의 비트코인 주소로 보내주면 된다.비트코인 주소는 일반적인 경우 1, 다중 서명이 가능한 경우 3으로 시작하는 34자 길이로 되어있다.일반적인 비트코인 주소를 생성하는 방법에 대해 알아보자비트코인을 포함한 모든 블록체인 시스템에는 거래를 생성할 때 전자서명 알고리즘을 활용하고 있다.예를 들어 비트코인을 거래할 때 비트코인을 전송하는 사람이 자신의 개인키로 서명을 하고 거래 정보와 자신의 공개키를 상대방의 비트코인 주소로 전달하면 비트코인을 받는 사람은 동봉된 공개키가 그 사람의 공개키로 서명을 확인하고 검증되면 거래가 성사된다.비트코인에 활용되는 공개키 시스템은 비트코인 주소를 만드는 것에도 활용된다. 비트코인 주소는 이 비트코인 주소 소유자의 공개키를 기반으로 만들어진다. 비트코인에 적용되는 전자 서명 알고리즘은 ECDSA이다.  개인키를 이용해 ECDSA 공개키를 얻음  EDCSA 공개키의 앞부분에 “0x04”를 추가한다.  2단계에서 얻은 값의 SHA-256 해시값을 얻고, 이 해시값에 RIPEMD-160을 적용한 값을 얻는다.  3단계에서 얻은 값에 앞에 “0x00”을 추가한다.  4단계에서 얻은 값의 더블 SHA-256 해시값을 얻는다.  5단계에서 얻은 값의 첫 4바이트를 체크섬으로 둔다.  4단계에서 얻은 Base58 인코딩을 적용한 값을 비트코인  주소로 한다.이 순서를 순서도로 보면여기서 등장하는  RIPEMD-160 은 1996년 벨기에의 루벤 카톨릭 대학의 COSIC 연구그룹에서 MD4를 기반으로 개발한 해시 알고리즘이다.RIPEMD-160은 임의의 입력값에 대해 160비트 크기의 해시값을 출력하며, 32비트 연산에 최적화 되어있다.비트코인 주소 생성 메커니즘을 파이썬으로 구현한 코드이다.# pip install base58check# pip install ecdsaimport osimport hashlibfrom hashlib import sha256 as shafrom base58check import b58encodeimport ecdsadef ripemd160(x):    ret = hashlib.new(\"ripemd160\")    ret.update(x)        return retdef generateBitcoinAdress():    # 개인키 생성    privkey = os.urandom(32)    fullkey = \"80\" + privkey.hex()    a = bytes.fromhex(fullkey)    sha_a = sha(a).digest()    sha_b = sha(sha_a).hexdigest()    c = bytes.fromhex(fullkey+sha_b[:8])    # WIF = Wallet Import Format -&gt; 비트코인 거래를 위한 약식 개인키    WIF = b58encode(c)    # 1단계 ECDSA 공개키 획득    signing_key = ecdsa.SigningKey.from_string(privkey, curve=ecdsa.SECP256k1)    verifying_key = signing_key.get_verifying_key()    pubkey = (verifying_key.to_string()).hex()    # 2단계    pubkey = \"04\" + pubkey    # 3단계    pub_sha = sha(bytes.fromhex(pubkey)).digest()    encPubkey = ripemd160(pub_sha).digest()    # 4단계    encPubkey = b\"\\x00\" + encPubkey    # 5단계    chunck = sha(sha(encPubkey).digest()).digest()    # 6단계    checksum = chunck[:4]    # 7단계    hex_address = encPubkey + checksum    # 8단계    bitcoinAdress = b58encode(hex_address)    # WIF와 생성된 비트코인 주소 출력    print(\"+++WIF = \", WIF.decode())    print(\"+++Bitcoin Adress = \", bitcoinAdress.decode())generateBitcoinAdress()",
            "content_html": "<h2 id=\"블록체인의-개념과-구조\">블록체인의 개념과 구조</h2><p>블록체인은 단어 그대로 해석해보면 블록이 서로 연결되어 있다라는 의미이다. 여기서 블록이란 거래(or 트랜잭션) 기록을 담고있는 장부의 한 페이지라고 생각하면 이해가 쉽다.즉 블록에는 거래 당사자들의 모든 거래 내용을 담고 있으며 일정한 조건을 만족하면 하나의 블록을 완성시키고 다음 블록에 새로운 거래 내용을 기록하게 된다. 여기서 일정한 조건이란 나중에 설명할 블록 생성을 위한 합의 알고리즘이다.</p><p>다음 블록에는 이전 블록들의 모든 정보를 압축하여 담아 두는데, 이를 위해 SHA-256해시를 활용한다.이러한 블록들은 거래가 참여하는 모든 당사자들에게 공유됨으로써 거래에 대한 투명성을 높이고 이전 블록들의 압축된 정보를 다음 블록에 기록함으로써 위조나 변조가 매우 힘들도록 한 것이다.</p><p>블록체인을 한 문장으로 정의하면 다음과 같이 요약할 수 있다.</p><hr /><p>“블록”이라고 하는 거래 기록을 담고있는 데이터들이 거래 참여자들의 합의에 생선된 체인 형태의 연결고리를 가진 형태로 구성되어 모든 거래 참여자들에 배포되며, 누구나 기록된 거래 내용의 결과를 열람할 수 있지만, 어느 누구도 임의로 수정할 수 없도록 만든 분산 컴퓨팅 기반의 데이터 위변조 방지 기술이다.</p><hr /><p>블록체인은 일반적으로 다음과 같은 구조를 띈다.</p><p><img src=\"https://0o3q.github.io/images/2023-04-12-blockchain_wih_bitcoin/blockchain_structure.png\" alt=\"Image blockchain_structure\" /></p><p>블록체인은 블록 1에서부터 거래를 기록하게 되며 특정한 조건인 합의 알고리즘을 통해 블록 1에 더이상 거래를 기록할 수 없도록 블록을 동결하고 완성시킨다.블록 1에 기록된 정보를 대표하는 해시값 Hash1을 생성하고 Hash1은 다음 블록인 블록 2에 기록한다. 블록 2도 특정한 조건에 만족하면 블록 1과 같은 과정으로 거치고 그 다음 블록인 블록 3에 거래를 기록하는 방식으로 진행된다. 이런식으로 구성되는 블록체인은 거래에 참여하는 모든 당사자들에게 배포된다.</p><p>블록체인에서 첫 번째 블록인 블록 1을 “제네시스 블록”이라 부르고 이 블록의 정보가 거짓이라면 블록체인의 전체 정보가 거짓이 되기 때문에 제네시스 블록에는 반드시 참 값을 기록해야 한다.</p><p>블록체인을 구성하는 블록의 일반적인 구조는 다음과 같다.</p><p><img src=\"https://0o3q.github.io/images/2023-04-12-blockchain_wih_bitcoin/block_structure.png\" alt=\"Image block_structure\" /></p><p>블록은 블록헤더(block header)와 블록몸체(block body)로 이루어져 있다. 블록몸체에는 거래를 기록하며, 블록헤더에는 이전 블록헤더의 해시값, 현재 블록에 기록되어 있는 전체 거래에 대한 해시값 그리고 기타 정보들이 기록되어 있다. 블록헤더의 기타 정보 부분은 블록체인의 종류에 따라 기록되는 데이터가 다르다.</p><p>블록헤더에 기록되어 있는 해시값은 모두 SHA-256을 이용한다. 블록헤더에 기록된 현 블록의 전체 트랜잭션에 대한 해시값은 머클트리(Merkle Tree)라는 방법으로 계산되는데, 그림에서 보는 것처럼 피라미드구조와 같이 2개의 트랜잭션에 대한 해시값을 짝지어 이 2개의 해시값에 대한 해시값을 계산하는 방법으로 피라미드 꼭대기에 있는 1개의 해시값으로 만드는 것이다.피라미드 꼭대기에 있는 해시값을 머클루트(Merkle Root)라 부르며, 이 머클루트가 블록헤더의 전체 트랜잭션 해시값이 되는 것이다.</p><p>따라서 블록헤더에는 현재 블록의 전체 거래 기록들의 압축된 정보가 기록되어 있는 셈이다.이 블록헤더에 대한 해시값은 나중에 다음 블록의 블록헤더에 이전 블록 해시값 부분에 기록된다.</p><p>물론 블록헤더에 기록되는 머클루트는 블록이 완성되기까지 거래기록이 추가되면 계속 변하는 값이다. 다음 블록에 기록할 현재 블록헤더에 대한 해시값은 블록에 더 이상 거래를 기록할 수 없도록 한 상태에서 만들어진다.</p><p>블록몸체에 기록되는 거래 즉 트랜잭션 데이터는 거래 정보와 부가 데이터를 저장할 수 있는 공간으로 되어있다.</p><p>지금까지 설명한 블록체인의 구조는 블록체인의 종류에 상관없이 거의 공통적인 내용이며, 블록이 만들어지는 조건인 합의 알고리즘이나 블록의 크기등이 블록체인의 종류에 따라 달라진다.</p><h2 id=\"블록체인과-작업증명\">블록체인과 작업증명</h2><p>블록체인에선 블록은 거래 참여자들의 합의에 의해 생성되고 배표된다고 언급했다. 합의 알고리즘은 분산 네트워크 상에 존재하는 서로 신뢰할 수 없는 정보들에 대해 수학적으로 계산된 값을 특정 절차에 따라 상호 검증하여 신뢰 가능하도록 보장하는 알고리즘이다.블록체인의 연결 구조와 합의 알고리즘이라는 메커니즘을 통해 블록체인에 담긴 정보들의 위조나 변조가 매우 어려워진다.</p><p>블록체인에서 활용되는 합의 알고리즘은 다양하게 존재하는데 대표적으로 작업증명(Proof Of Work), 지분증명(Proof Of Stake), PBFT(Practical Byzantine Fault Tolerance), RAFT 등이 있다.</p><p>우선 해시와 매우 밀접한 작업 증명에 대해서만 알아본다.</p><p>작업증명은 주어진 해시값보다 작아지도록 SHA-256에 입력되는 값을 찾아내는 것이다.작업증명의 난이도는 주어진 해시값에 따라 달라진다.</p><hr /><p>문제 1</p><p>SHA-256(value) ≤ 000c007…3c240b36c312</p><hr /><p>위 문제 1을 만족하는 value를 찾아낸느 것이 작업증명의 메커니즙이다. 작업증명을 더 쉽게 이해할 수 있도록 다음의 문제를 생각해보자</p><hr /><p>“Attack at 9PM!”이라는 문자에 대한 SHA-256해시값은 다음과 같다.</p><p>SHA-256(”Attack at 9PM!”) = c53ae0b1db6f94ce4177112…9f5a19f47d473a785dc97afc</p><hr /><p>이제 “Attack at 9PM!” 문장 뒤에 숫자 0을 더해서 SHA-256 해시값을 계산해보면 다음과 같은 결과가 나온다.</p><hr /><p>SHA-256(”Attack at 9PM!0”) = 8eb6977a7765fda7cf7d6…20ede2b3c371ab6c9adc41a0</p><hr /><p>여기서 문제를 제시한다.</p><hr /><p>문제 2</p><p>“Attack at 9PM!”에 어떤 숫자를 추가하여 구한 SHA-256 해시값이 00으로 시작되도록하는 어떤 숫자를 구하라</p><hr /><p>문제 2를 풀기 위해서는 “Attack at 9PM!”에 0을 추가하여 SHA-256 해시값을 구하고 을 추가하여 SHA-256 해시값을 구하는식으로 부르트포싱하여 구한 해시값이 00으로 시작되는 그 숫자를 찾으면 된다.</p><p>가장 최초로 나타나는 값은 240이다.</p><p>문제 2와 같은 유형의 문제를 해시캐시(hashcash)라고 부른다. 해시캐시 문제의 답을 구하려면 그냥 무식하게 부르트포싱하는 방법뿐이다. 부르트포싱하며 원래 메세지에 추가하는 값을 nounce라고 한다. 즉 해시캐시 문제는 주어진 해시값고 같아지는 nounce 값을 찾는 것이다.</p><p>문제 2에서 주어진 문제가 00으로 시작하는게 아닌 000으로 시작하는 해시값이면 난이도는 더욱 올라가고 nounce는 6541이 된다. 따라서 0의 개수가 많아질 수록 해시캐시 문제의 난이도는 증가한다.</p><p>작업증명은 해시캐시 문제를 푸는 원리와 동일하다</p><p>다음은 문장 “Attack at 9PM!”에 대한 해시캐시를 구하는 파이썬 코드이다.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"nn\">hashlib</span> <span class=\"kn\">import</span> <span class=\"n\">sha256</span> <span class=\"k\">as</span> <span class=\"n\">sha</span><span class=\"k\">def</span> <span class=\"nf\">hashcash</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">difficulty</span><span class=\"p\">):</span>    <span class=\"n\">nounce</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"+++ Start\"</span><span class=\"p\">)</span>    <span class=\"k\">while</span> <span class=\"bp\">True</span><span class=\"p\">:</span>        <span class=\"n\">target</span> <span class=\"o\">=</span> <span class=\"s\">\"%s%d\"</span> <span class=\"o\">%</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">nounce</span><span class=\"p\">)</span>        <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">sha</span><span class=\"p\">(</span><span class=\"n\">target</span><span class=\"p\">.</span><span class=\"n\">encode</span><span class=\"p\">()).</span><span class=\"n\">hexdigest</span><span class=\"p\">()</span>        <span class=\"k\">if</span> <span class=\"n\">ret</span><span class=\"p\">[:</span><span class=\"n\">difficulty</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s\">'0'</span><span class=\"o\">*</span><span class=\"n\">difficulty</span><span class=\"p\">:</span>            <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"++++ Bingo\"</span><span class=\"p\">)</span>            <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"---&gt;\"</span><span class=\"p\">,</span> <span class=\"n\">ret</span><span class=\"p\">)</span>            <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"---&gt; NOUNCE = %d\"</span> <span class=\"o\">%</span><span class=\"n\">nounce</span><span class=\"p\">)</span>            <span class=\"k\">break</span>        <span class=\"n\">nounce</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span><span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>    <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s\">\"Attack at 9PM!\"</span>    <span class=\"n\">difficulty</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>    <span class=\"n\">hashcash</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">difficulty</span><span class=\"p\">)</span><span class=\"k\">if</span> <span class=\"n\">__name__</span> <span class=\"o\">==</span> <span class=\"s\">\"__main__\"</span><span class=\"p\">:</span>    <span class=\"n\">main</span><span class=\"p\">()</span></code></pre></div></div><p>difficulty의 개수에 따라 0의 개수가 정해지며 difficulty가 커지면 시간도 그에 맞게 커진다.</p><p>비트코인에서 사용되는 작업증명은 비트코인의 작업증명에서 자세히 다룬다.</p><h2 id=\"작업증명의-효과\">작업증명의 효과</h2><p>앞에서 제시한 해시캐시는 난이도가 매우 낮아서 일반 PC 1대로도 순식간에 nounce를 구할 수 있다.하지만 비트코인이나 이더리움같은 블록체인 네트워크에서는 네크워크에 참여하는 모든 노드(실제로는 블록을 생성하기 위해 참여한 노드)의컴퓨팅 파워를 총 동원하여 일정한 시간동안 계산해야만 nounce를 구할 수 있을 정도로 해시캐시 난이도를 조정한다.</p><p>비트코인의 경우 참여하는 모든 노드의 컴퓨팅 파워를 동원하여 10분 정도 걸리는 해시캐시 난이도로 설정한다.</p><p>실제 작업증명의 메커니즘은 다음과 같다.</p><ol>  <li>거래 정보가 담긴 1번 블록의 정보를 이용해 해시캐시 문제를 제시한다.</li>  <li>제시된 해시캐시 문제는 블록체인에 참여한 모든 노드의 컴퓨팅 파워로 10분정도 걸려야 풀 수 있는 난이도로 설정되어 있다.</li>  <li>특정 노드에서 해시캐시 문제의 답을 구했다면 1번 블록에 정답을 기록하고 더 이상의 거래 기록을 담지 못하게 동결하고 이 블록을 모든 참여 노드에 전달한다.</li>  <li>해시캐시 문제의 정답을 구하는 것은 어렵지만 답을 구하면 그 답이 정답인지 검증하는 것은 매우 쉽다. 따라서 블록을 전달받은 모든 블록에 포함된 해시캐시 정답을 검증하고 정말 정답이면 블록을 수용하고 그렇지 않으면 블록을 폐기한다.</li>  <li>새로운 2번 블록에 거래를 기록한다.</li>  <li>2번 이후 블록에 대해 1~5 과정을 반복한다.</li></ol><p>이제 다음과 같은 상황을 가정한다.</p><p>100개의 노드(각 노드는 동일한 컴퓨팅 파워를 가지고 있다고 가정한다.)가 블록체인 네트워크에 참여하고 있고, 현재 n번째 블록까지 생성된 상태이다. 100개의 노드 중 10개의 노드가 n+1번째 블록의 거래 내용을 조작한다고 할 때, 작업증명의 효과로 다음과 같은 상황이 된다.</p><p><img src=\"https://0o3q.github.io/images/2023-04-12-blockchain_wih_bitcoin/pow_effect.png\" alt=\"Image pow_effect\" /></p><ul>  <li>조작된 n+1번째 블록 내용을 기반으로 100개의 노드가 10분간 풀어야할 해시캐시 문제를 10개 노드가 해결해야한다.</li>  <li>그동안 정상적인 n+1번째 블록 내용을 기반으로 100개의 노드가 10분간 풀어야할 해시캐시 문제를 90개의 노드가 해결하고 있는 중이다.</li>  <li>확률적으로 정상적인 n+1번째 블록에 대한 해시캐시 문제가 훨씬 빨리 해결될 것이고, n+1번째 블록을 생성한 후 n+2번째 블록에 대한 해시캐시 문제를 90개의 노드가 해결하고 있는 상황이 된다.</li>  <li>이제 10개의 노드는 n+1번째 블록뿐만 아니라 n+2번째의 블록에 대한 해시캐시 문제를 해결해야 되는 지경에 이른다.</li></ul><p>이런 원리를 통해 10개의 노드는 블록의 내용을 위변조하는 것은 거의 불가능에 가깝게 된다.따라서 블록체인에서 작업증명의 효과는 블록체인 구조에서 기인되는 위변조 조작의 어려움에 더해 더욱 위변조가 어려워지도록 하는 효과를 가진다.</p><p>이럼에도 불구라고 1개의 노드가 조작된 블록에 해시캐시 문제를 해결하고 모든 노드에 배표하게 된다면, 조작된 블로깅 포함된 브록체인의 기링가 정상적인 블록체인의 길이보다 짧을 것이다.</p><p><img src=\"https://0o3q.github.io/images/2023-04-12-blockchain_wih_bitcoin/pow_effect2.png\" alt=\"Image pow_effect2\" /></p><p>블록체인 시스템은 2개이상의 블록체인이 배포될때 길이가 딘 블록체인의 채캑을 원칙으로 하고 있다.</p><h2 id=\"비트코인의-블록구조\">비트코인의 블록구조</h2><p>비트코인은 브록체인 기술을 활용한 최초의 분산원장 기술이자 가장 잘 알려진 암호화폐 시스템이다. 비트코인을 기본적으로 이해하고 있다면 다른 블록체인 시스템에 대해 보다 쉽게 접근할 수 있다.</p><p>비트코인의 즐록 구조는 블록체인의 일반적인 구종와 동일하다. 실제 비트코인의 블록에는 다음의 그림과 같은 정보들로 구성되어 있다.</p><p><img src=\"https://0o3q.github.io/images/2023-04-12-blockchain_wih_bitcoin/bitblock_structure.png\" alt=\"Image bitblock_structure\" /></p><p>위 그림처럼 매직넘버와 블록 크기를 나타내는 필드를 제외하면 비트코인 블록은 블록헤더와 블록몸체로 구성되어 있는 것을 볼 수 있다. 블록헤더는 총 6개의 필드로 구성되어 있고, 블록몸체에는 거래 개수와 거래 정보가 담겨있다.</p><p>블록 몸체를 이루는 값들에 대해 간단히 살펴보면 Trancsaction counter는 블록몸체에 기록된 거래 개수이다. 거래 정보가 블록봅체에 추가될 때마다 Transaction counter는 1증가한다.</p><p>블록몸체에서 Coinbase transaction은 새로운 블록이 생성될 때 블록몸체에 최초로 기록되는 거래 정보로. 생성 거래로 부르기도 하며 초기에는 무의미한 값들로 구성되어 있다. 하지만 작업증명이 성공하게 되면 새로 발행되는 비트코인을 성공한 노드의 비트코인 주소로 입금하는 거래 정보로 변경된다.</p><p>블록헤더의 6개 필드 중 첫 3개는 앞에서 설명했으니 Time 필드부터 살펴본다.Time 필드는 현재 시간을 기록하는 타임스탬프 역할을 하는데, 이 값은 몇 초마다 갱신되며 블록이 완성될 때까지 지속적으로 변한다.</p><p>Bits는 작업증명을 위한 대상값(Target)을 저장하는 부분인데 실제로는 Bits에 저장된 값을 특정 공식에 적용하여 대상값을 산출해내며, 이 대상값보다 블록헤더의 해시값이 작아지게 되는 nounce를 구하면 작업증명에 성공하게 된다. 이에 대해서는 실제 비트코인 블록헤더를 이용하여 작업증명 메커니즘을 설명할 때 알아본다.</p><p>Bits는 비트코인 네트워크에 참여하고 있는 노드의 수에 따라 값이 변하는데, 앞에서 설명한 바와 같이 모든 참여자 노드의 컴퓨팅 파워를 이용해 해시캐시 문제를 10분 정도 걸려야 풀 수 있도록 조정된다.</p><p>다음은 실제 비트코인의 125,552번째 블록헤더의 내용이다.</p><p><img src=\"https://0o3q.github.io/images/2023-04-12-blockchain_wih_bitcoin/12552bit.png\" alt=\"Image 12552bit\" /></p><p>위 그림에서 각 필드의 값들은 모두 리클 엔디안 방식으로 메모리에 저장되어 있는 값을 보여주고 있다.</p><p>인텔 x86 계열의 CPU는 리틀 엔디안 방식으로 메모리에 데이터를 저장한다.리틀 엔디안이란 하뉘 주소의 메모리에 낮은 자리의 숫자를 기록하는 방식이다.16진수 0x1b0404cb를 리틀 엔디안으로 메모리에 저장하면 다음과 같다.</p><p><img src=\"https://0o3q.github.io/images/2023-04-12-blockchain_wih_bitcoin/little.png\" alt=\"Image little\" /></p><p>따라서 실제 위 그림의 블록헤더에 저장되어 있는 Bits의 값은 0x1a449b2f, Nounce의 값은 0x9546a142이다.</p><h2 id=\"비트코인의-작업증명\">비트코인의 작업증명</h2><p>비트코인의 작업증명은 블록헤더 6개 필드에 대한 해시캐시를 구하는 문제이다. 해시캐시의 난이도는 Bits 필드에 저장된 Target값으로 결정된다.</p><hr /><p>비트코인 작업증명</p><p>SHA-256(블록헤더 6개 필드) ≤ Target</p><hr /><p>Targt값은 Bits에 저장된 값을 특정 변환 공식을 적용하여 얻어진다.비트코인의 난이도 설정값인 4바이트 크기의 Bits를 Target값으로 변환하는 공식은 다음과 같다.</p><hr /><p>Bits의 값이 0x1a44b9f2인 경우,</p><ol>  <li>Bits의 앞 2자리와 쥐 6자리를 다음과 같이 분리함</li>  <li>1a 44b9f2</li>  <li>Target = 0x44b9f2 * 2<em>*(8</em>(0x1a-3))</li></ol><hr /><p>다음은 리틀 엔디안 으로 저장된 Bits를 Target으로 변환하는 파이썬 코드다.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"nn\">hashlib</span> <span class=\"kn\">import</span> <span class=\"n\">sha256</span> <span class=\"k\">as</span> <span class=\"n\">sha</span><span class=\"kn\">import</span> <span class=\"nn\">codecs</span><span class=\"c1\">#인자 bits를 실제 16진수 값으로 리턴</span><span class=\"k\">def</span> <span class=\"nf\">decodeBitcoinVal</span><span class=\"p\">(</span><span class=\"n\">bits</span><span class=\"p\">):</span>    <span class=\"n\">decode_hex</span> <span class=\"o\">=</span> <span class=\"n\">codecs</span><span class=\"p\">.</span><span class=\"n\">getdecoder</span><span class=\"p\">(</span><span class=\"s\">'hex_codec'</span><span class=\"p\">)</span>    <span class=\"n\">binn</span> <span class=\"o\">=</span> <span class=\"n\">decode_hex</span><span class=\"p\">(</span><span class=\"n\">bits</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">]</span>    <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">codecs</span><span class=\"p\">.</span><span class=\"n\">encode</span><span class=\"p\">(</span><span class=\"n\">binn</span><span class=\"p\">[::</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"s\">'hex_codec'</span><span class=\"p\">)</span>    <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"k\">def</span> <span class=\"nf\">getTarget</span><span class=\"p\">(</span><span class=\"n\">bits</span><span class=\"p\">):</span>    <span class=\"n\">bits</span> <span class=\"o\">=</span> <span class=\"n\">decodeBitcoinVal</span><span class=\"p\">(</span><span class=\"n\">bits</span><span class=\"p\">)</span>    <span class=\"n\">bits</span> <span class=\"o\">=</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">bits</span><span class=\"p\">,</span> <span class=\"mi\">16</span><span class=\"p\">)</span>    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"Bits = %x\"</span> <span class=\"o\">%</span><span class=\"n\">bits</span><span class=\"p\">)</span>    <span class=\"n\">bit1</span> <span class=\"o\">=</span> <span class=\"n\">bits</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">4</span><span class=\"o\">*</span><span class=\"mi\">6</span>    <span class=\"n\">base</span> <span class=\"o\">=</span> <span class=\"n\">bits</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0x00ffffff</span>    <span class=\"n\">sft</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">bit1</span> <span class=\"o\">-</span> <span class=\"mh\">0x3</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"mi\">8</span>    <span class=\"n\">target</span> <span class=\"o\">=</span> <span class=\"n\">base</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">sft</span>    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"Target = %x\"</span> <span class=\"o\">%</span><span class=\"n\">target</span><span class=\"p\">)</span><span class=\"n\">Bits</span> <span class=\"o\">=</span> <span class=\"s\">\"f2b9441a\"</span><span class=\"n\">getTarget</span><span class=\"p\">(</span><span class=\"n\">Bits</span><span class=\"p\">)</span></code></pre></div></div><p>실제 비트코인의 125,552번째의 Bits값 사용</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">decodeBitcoinVal</span><span class=\"p\">(</span><span class=\"n\">bits</span><span class=\"p\">):</span>    <span class=\"n\">decode_hex</span> <span class=\"o\">=</span> <span class=\"n\">codecs</span><span class=\"p\">.</span><span class=\"n\">getdecoder</span><span class=\"p\">(</span><span class=\"s\">'hex_codec'</span><span class=\"p\">)</span>    <span class=\"n\">binn</span> <span class=\"o\">=</span> <span class=\"n\">decode_hex</span><span class=\"p\">(</span><span class=\"n\">bits</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">]</span>    <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">codecs</span><span class=\"p\">.</span><span class=\"n\">encode</span><span class=\"p\">(</span><span class=\"n\">binn</span><span class=\"p\">[::</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"s\">'hex_codec'</span><span class=\"p\">)</span>    <span class=\"k\">return</span> <span class=\"n\">ret</span></code></pre></div></div><p>위 코드에서 리틀 엔디안으로 표현된 16진수값을 받아와 실제 16진수 순서로 변환한 후 정수 값으로 리턴한다.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">getTarget</span><span class=\"p\">(</span><span class=\"n\">bits</span><span class=\"p\">):</span>    <span class=\"n\">bits</span> <span class=\"o\">=</span> <span class=\"n\">decodeBitcoinVal</span><span class=\"p\">(</span><span class=\"n\">bits</span><span class=\"p\">)</span>    <span class=\"n\">bits</span> <span class=\"o\">=</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">bits</span><span class=\"p\">,</span> <span class=\"mi\">16</span><span class=\"p\">)</span>    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"Bits = %x\"</span> <span class=\"o\">%</span><span class=\"n\">bits</span><span class=\"p\">)</span>    <span class=\"n\">bit1</span> <span class=\"o\">=</span> <span class=\"n\">bits</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">4</span><span class=\"o\">*</span><span class=\"mi\">6</span>    <span class=\"n\">base</span> <span class=\"o\">=</span> <span class=\"n\">bits</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0x00ffffff</span>    <span class=\"n\">sft</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">bit1</span> <span class=\"o\">-</span> <span class=\"mh\">0x3</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"mi\">8</span>    <span class=\"n\">target</span> <span class=\"o\">=</span> <span class=\"n\">base</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">sft</span>    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"Target = %x\"</span> <span class=\"o\">%</span><span class=\"n\">target</span><span class=\"p\">)</span></code></pre></div></div><p>Bits를 Target값으로 변환하는 공식 구현</p><p>1비트를 오른쪽으로 쉬프트하면 원래의 값에 2를 곱한 것과 동일하다. 반대로 1비트를 왼쪽으로 쉬프트하면 2를 나눈 것과 동일하다.</p><p>16진수는 4비트로 표현되므로 A»4와 A«4는 각각 원래의 값 A에 대해 16진수 자리수를 한자리 내리거나 또는 한자리 올린다는 의미와 같다.</p><p>코드를 실행하면 Target이 다음과 같이 출력된다.</p><hr /><p>Target = 44b9f20000000000000000000000000000000000000000000000</p><hr /><p>비트코인에서 Target은 해시캐시 문제를 풀기 위한 대상이라고 했다. 비트코인 블록헤더에 기록된 6개 필드에 대한 SHA-256 해시값이 이 값보다 작게 되는 nounce값을 찾는 것이다.</p><p>SHA-256 해시는 32바이트로 표현되므로, 위 Target을 32바이트로 표현하면 다음과 같은 값이 된다.</p><hr /><p>Target = 00000000000044b9f20000000000000000000000000000000000000000000000</p><hr /><p>따라서 다음의 식을 만족하는 Nounce 값을 계산해야 비트코인의 125.552번째 블록이 완성된다.</p><hr /><p>SHA-256(Version+HashPrevBlock+HashMerkleRoot+Time+Bits+Nounce) ≤ 00000000000044b9f20000000000000000000000000000000000000000000000</p><hr /><p>다음 코드는 비트코인의 125,532번째 블록에 대해 Nounce값을 검증하는 코드이다. 비트코인의 125,532번째 블록은 이미 오래전에 만들어진 블록이므로 기록된 Nounce값이 위 해시캐시 문제를 만족하는 값일 것이다</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"nn\">hashlib</span> <span class=\"kn\">import</span> <span class=\"n\">sha256</span> <span class=\"k\">as</span> <span class=\"n\">sha</span><span class=\"kn\">import</span> <span class=\"nn\">codecs</span><span class=\"c1\">#인자 bits를 실제 16진수 값으로 리턴</span><span class=\"k\">def</span> <span class=\"nf\">decodeBitcoinVal</span><span class=\"p\">(</span><span class=\"n\">bits</span><span class=\"p\">):</span>    <span class=\"n\">decode_hex</span> <span class=\"o\">=</span> <span class=\"n\">codecs</span><span class=\"p\">.</span><span class=\"n\">getdecoder</span><span class=\"p\">(</span><span class=\"s\">'hex_codec'</span><span class=\"p\">)</span>    <span class=\"n\">binn</span> <span class=\"o\">=</span> <span class=\"n\">decode_hex</span><span class=\"p\">(</span><span class=\"n\">bits</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">]</span>    <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">codecs</span><span class=\"p\">.</span><span class=\"n\">encode</span><span class=\"p\">(</span><span class=\"n\">binn</span><span class=\"p\">[::</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"s\">'hex_codec'</span><span class=\"p\">)</span>    <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"k\">def</span> <span class=\"nf\">getTarget</span><span class=\"p\">(</span><span class=\"n\">bits</span><span class=\"p\">):</span>    <span class=\"n\">bits</span> <span class=\"o\">=</span> <span class=\"n\">decodeBitcoinVal</span><span class=\"p\">(</span><span class=\"n\">bits</span><span class=\"p\">)</span>    <span class=\"n\">bits</span> <span class=\"o\">=</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">bits</span><span class=\"p\">,</span> <span class=\"mi\">16</span><span class=\"p\">)</span>    <span class=\"n\">bit1</span> <span class=\"o\">=</span> <span class=\"n\">bits</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">4</span><span class=\"o\">*</span><span class=\"mi\">6</span>    <span class=\"n\">base</span> <span class=\"o\">=</span> <span class=\"n\">bits</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0x00ffffff</span>    <span class=\"n\">sft</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">bit1</span> <span class=\"o\">-</span> <span class=\"mh\">0x3</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"mi\">8</span>    <span class=\"n\">target</span> <span class=\"o\">=</span> <span class=\"n\">base</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">sft</span>    <span class=\"k\">return</span> <span class=\"n\">target</span><span class=\"c1\"># 아래에는 2011년 5월에 생성된 비트코인 125,552번째 블록에 대한 작업 증명이 성공했음을 검증하는 코드이다.</span><span class=\"k\">def</span> <span class=\"nf\">validatePoW</span><span class=\"p\">(</span><span class=\"n\">header</span><span class=\"p\">):</span>    <span class=\"n\">block_version</span> <span class=\"o\">=</span> <span class=\"n\">header</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>    <span class=\"n\">hashPrecBlock</span> <span class=\"o\">=</span> <span class=\"n\">header</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>    <span class=\"n\">hashMerkleRoot</span> <span class=\"o\">=</span> <span class=\"n\">header</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span>    <span class=\"n\">Time</span> <span class=\"o\">=</span> <span class=\"n\">header</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">]</span>    <span class=\"n\">Bits</span> <span class=\"o\">=</span> <span class=\"n\">header</span><span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">]</span>    <span class=\"n\">nounce</span> <span class=\"o\">=</span> <span class=\"n\">header</span><span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">]</span>    <span class=\"c1\">#블록 헤더의 모든 값을 더하고 이름 바이트 객체로 변경</span>    <span class=\"n\">decode_hex</span> <span class=\"o\">=</span> <span class=\"n\">codecs</span><span class=\"p\">.</span><span class=\"n\">getdecoder</span><span class=\"p\">(</span><span class=\"s\">'hex_codec'</span><span class=\"p\">)</span>    <span class=\"n\">header_hex</span> <span class=\"o\">=</span> <span class=\"n\">block_version</span><span class=\"o\">+</span><span class=\"n\">hashPrecBlock</span><span class=\"o\">+</span><span class=\"n\">hashMerkleRoot</span><span class=\"o\">+</span><span class=\"n\">Time</span><span class=\"o\">+</span><span class=\"n\">Bits</span><span class=\"o\">+</span><span class=\"n\">nounce</span>    <span class=\"n\">header_bin</span> <span class=\"o\">=</span> <span class=\"n\">decode_hex</span><span class=\"p\">(</span><span class=\"n\">header_hex</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">]</span>    <span class=\"c1\"># 실제 비트코인에서는 블록헤더의 SHA-256 해시에 대한 SHA256해시를 이용해서 작업증명을 한다.</span>    <span class=\"nb\">hash</span> <span class=\"o\">=</span> <span class=\"n\">sha</span><span class=\"p\">(</span><span class=\"n\">header_bin</span><span class=\"p\">).</span><span class=\"n\">digest</span><span class=\"p\">()</span>    <span class=\"nb\">hash</span> <span class=\"o\">=</span> <span class=\"n\">sha</span><span class=\"p\">(</span><span class=\"nb\">hash</span><span class=\"p\">).</span><span class=\"n\">digest</span><span class=\"p\">()</span>    <span class=\"n\">PoW</span> <span class=\"o\">=</span> <span class=\"n\">codecs</span><span class=\"p\">.</span><span class=\"n\">encode</span><span class=\"p\">(</span><span class=\"nb\">hash</span><span class=\"p\">[::</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"s\">'hex_codec'</span><span class=\"p\">)</span>    <span class=\"c1\">#헤더의 Bits 값을 이요해 실제 target 값 추출</span>    <span class=\"n\">target</span> <span class=\"o\">=</span> <span class=\"n\">getTarget</span><span class=\"p\">(</span><span class=\"n\">Bits</span><span class=\"p\">)</span>    <span class=\"n\">target</span> <span class=\"o\">=</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"nb\">hex</span><span class=\"p\">(</span><span class=\"n\">target</span><span class=\"p\">))</span>    <span class=\"n\">target</span> <span class=\"o\">=</span> <span class=\"s\">'0'</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">66</span><span class=\"o\">-</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">target</span><span class=\"p\">))</span> <span class=\"o\">+</span> <span class=\"n\">target</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">:]</span>    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"target</span><span class=\"se\">\\t</span><span class=\"s\">=\"</span><span class=\"p\">,</span> <span class=\"n\">target</span><span class=\"p\">)</span>    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"BlockHash</span><span class=\"se\">\\t</span><span class=\"s\">=\"</span><span class=\"p\">,</span> <span class=\"n\">PoW</span><span class=\"p\">.</span><span class=\"n\">decode</span><span class=\"p\">())</span>    <span class=\"c1\"># 작업 증명이 성공한 건지 체크</span>    <span class=\"k\">if</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">PoW</span><span class=\"p\">,</span> <span class=\"mi\">16</span><span class=\"p\">)</span> <span class=\"o\">&lt;=</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"mi\">16</span><span class=\"p\">):</span>        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"+++ Accept this Block\"</span><span class=\"p\">)</span>    <span class=\"k\">else</span><span class=\"p\">:</span>        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"--- Reject this Block\"</span><span class=\"p\">)</span><span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>    <span class=\"n\">block_version</span> <span class=\"o\">=</span> <span class=\"s\">\"01000000\"</span>    <span class=\"n\">hashPrevBlock</span> <span class=\"o\">=</span> <span class=\"s\">\"81cd02ab7e569e8bcd9317e2fe99f2de44d49ab2b8851ba4a308000000000000\"</span>    <span class=\"n\">hashMerkleRoot</span> <span class=\"o\">=</span> <span class=\"s\">\"e320b6c2fffc8d750423db8b1eb942ae710e951ed797f7affc8892b0f1fc122b\"</span>    <span class=\"n\">Time</span> <span class=\"o\">=</span> <span class=\"s\">\"c7f5d74d\"</span>    <span class=\"n\">Bits</span> <span class=\"o\">=</span> <span class=\"s\">\"f2b9441a\"</span>    <span class=\"n\">nounce</span> <span class=\"o\">=</span> <span class=\"s\">\"42a14695\"</span>    <span class=\"n\">header</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">block_version</span><span class=\"p\">,</span> <span class=\"n\">hashPrevBlock</span><span class=\"p\">,</span> <span class=\"n\">hashMerkleRoot</span><span class=\"p\">,</span> <span class=\"n\">Time</span><span class=\"p\">,</span> <span class=\"n\">Bits</span><span class=\"p\">,</span> <span class=\"n\">nounce</span><span class=\"p\">]</span>    <span class=\"n\">validatePoW</span><span class=\"p\">(</span><span class=\"n\">header</span><span class=\"p\">)</span><span class=\"n\">main</span><span class=\"p\">()</span></code></pre></div></div><p>실행 결과</p><p><code class=\"language-plaintext highlighter-rouge\">target  = 00000000000044b9f20000000000000000000000000000000000000000000000BlockHash       = 00000000000000001e8d6829a8a21adc5d38d0a473b144b6765798e61f98bd1d+++ Accept this Block</code></p><p><img src=\"https://0o3q.github.io/images/2023-04-12-blockchain_wih_bitcoin/pow_result.png\" alt=\"Image pow_result\" /></p><p>비트코인 블록 검색 사이트 아무거나 들어가면 일치하는 것을 볼 수 있다.</p><hr /><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">codecs</span><span class=\"c1\">#인자 bits를 실제 16진수 값으로 리턴</span><span class=\"k\">def</span> <span class=\"nf\">changeEndian</span><span class=\"p\">(</span><span class=\"n\">bits</span><span class=\"p\">):</span>    <span class=\"n\">decode_hex</span> <span class=\"o\">=</span> <span class=\"n\">codecs</span><span class=\"p\">.</span><span class=\"n\">getdecoder</span><span class=\"p\">(</span><span class=\"s\">'hex_codec'</span><span class=\"p\">)</span>    <span class=\"n\">binn</span> <span class=\"o\">=</span> <span class=\"n\">decode_hex</span><span class=\"p\">(</span><span class=\"n\">bits</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">]</span>    <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">codecs</span><span class=\"p\">.</span><span class=\"n\">encode</span><span class=\"p\">(</span><span class=\"n\">binn</span><span class=\"p\">[::</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"s\">'hex_codec'</span><span class=\"p\">)</span>    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">ret</span><span class=\"p\">)</span><span class=\"n\">Bits</span> <span class=\"o\">=</span> <span class=\"s\">\"2b12fcf1b09288fcaff797d71e950e71ae42b91e8bdb2304758dfcffc2b620e3\"</span><span class=\"n\">changeEndian</span><span class=\"p\">(</span><span class=\"n\">Bits</span><span class=\"p\">)</span></code></pre></div></div><p>쓸모 있을 지 모르지만 엔디안 바꾸는 코드이다.</p><h2 id=\"비트코인-주소-생성하기\">비트코인 주소 생성하기</h2><p>모든 블록체인 시스템은 은행계좌번호와 비슷한 역할을 하는 블록체인 주소라는 것이 있는데, 비트코인에서 이 주소를 비트코인 주소라고 부른다.A라는 사람이 B라는 사람에게 비트코인을 전송하려면, A의 비트코인 주소에 담겨있는 비트코인을 B의 비트코인 주소로 보내주면 된다.</p><p>비트코인 주소는 일반적인 경우 1, 다중 서명이 가능한 경우 3으로 시작하는 34자 길이로 되어있다.</p><p>일반적인 비트코인 주소를 생성하는 방법에 대해 알아보자비트코인을 포함한 모든 블록체인 시스템에는 거래를 생성할 때 전자서명 알고리즘을 활용하고 있다.</p><p>예를 들어 비트코인을 거래할 때 비트코인을 전송하는 사람이 자신의 개인키로 서명을 하고 거래 정보와 자신의 공개키를 상대방의 비트코인 주소로 전달하면 비트코인을 받는 사람은 동봉된 공개키가 그 사람의 공개키로 서명을 확인하고 검증되면 거래가 성사된다.</p><p>비트코인에 활용되는 공개키 시스템은 비트코인 주소를 만드는 것에도 활용된다. 비트코인 주소는 이 비트코인 주소 소유자의 공개키를 기반으로 만들어진다. 비트코인에 적용되는 전자 서명 알고리즘은 ECDSA이다.</p><p><img src=\"https://0o3q.github.io/images/2023-04-12-blockchain_wih_bitcoin/bitaddr.png\" alt=\"Image bitaddr\" /></p><ol>  <li>개인키를 이용해 ECDSA 공개키를 얻음</li>  <li>EDCSA 공개키의 앞부분에 “0x04”를 추가한다.</li>  <li>2단계에서 얻은 값의 SHA-256 해시값을 얻고, 이 해시값에 RIPEMD-160을 적용한 값을 얻는다.</li>  <li>3단계에서 얻은 값에 앞에 “0x00”을 추가한다.</li>  <li>4단계에서 얻은 값의 더블 SHA-256 해시값을 얻는다.</li>  <li>5단계에서 얻은 값의 첫 4바이트를 체크섬으로 둔다.</li>  <li>4단계에서 얻은 Base58 인코딩을 적용한 값을 비트코인  주소로 한다.</li></ol><p>이 순서를 순서도로 보면</p><p><img src=\"https://0o3q.github.io/images/2023-04-12-blockchain_wih_bitcoin/bitaddr2.png\" alt=\"Image bitaddr2\" /></p><p>여기서 등장하는  RIPEMD-160 은 1996년 벨기에의 루벤 카톨릭 대학의 COSIC 연구그룹에서 MD4를 기반으로 개발한 해시 알고리즘이다.RIPEMD-160은 임의의 입력값에 대해 160비트 크기의 해시값을 출력하며, 32비트 연산에 최적화 되어있다.</p><p>비트코인 주소 생성 메커니즘을 파이썬으로 구현한 코드이다.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># pip install base58check# pip install ecdsa</span><span class=\"kn\">import</span> <span class=\"nn\">os</span><span class=\"kn\">import</span> <span class=\"nn\">hashlib</span><span class=\"kn\">from</span> <span class=\"nn\">hashlib</span> <span class=\"kn\">import</span> <span class=\"n\">sha256</span> <span class=\"k\">as</span> <span class=\"n\">sha</span><span class=\"kn\">from</span> <span class=\"nn\">base58check</span> <span class=\"kn\">import</span> <span class=\"n\">b58encode</span><span class=\"kn\">import</span> <span class=\"nn\">ecdsa</span><span class=\"k\">def</span> <span class=\"nf\">ripemd160</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>    <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">hashlib</span><span class=\"p\">.</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"s\">\"ripemd160\"</span><span class=\"p\">)</span>    <span class=\"n\">ret</span><span class=\"p\">.</span><span class=\"n\">update</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>        <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"k\">def</span> <span class=\"nf\">generateBitcoinAdress</span><span class=\"p\">():</span>    <span class=\"c1\"># 개인키 생성</span>    <span class=\"n\">privkey</span> <span class=\"o\">=</span> <span class=\"n\">os</span><span class=\"p\">.</span><span class=\"n\">urandom</span><span class=\"p\">(</span><span class=\"mi\">32</span><span class=\"p\">)</span>    <span class=\"n\">fullkey</span> <span class=\"o\">=</span> <span class=\"s\">\"80\"</span> <span class=\"o\">+</span> <span class=\"n\">privkey</span><span class=\"p\">.</span><span class=\"nb\">hex</span><span class=\"p\">()</span>    <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"nb\">bytes</span><span class=\"p\">.</span><span class=\"n\">fromhex</span><span class=\"p\">(</span><span class=\"n\">fullkey</span><span class=\"p\">)</span>    <span class=\"n\">sha_a</span> <span class=\"o\">=</span> <span class=\"n\">sha</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">).</span><span class=\"n\">digest</span><span class=\"p\">()</span>    <span class=\"n\">sha_b</span> <span class=\"o\">=</span> <span class=\"n\">sha</span><span class=\"p\">(</span><span class=\"n\">sha_a</span><span class=\"p\">).</span><span class=\"n\">hexdigest</span><span class=\"p\">()</span>    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"nb\">bytes</span><span class=\"p\">.</span><span class=\"n\">fromhex</span><span class=\"p\">(</span><span class=\"n\">fullkey</span><span class=\"o\">+</span><span class=\"n\">sha_b</span><span class=\"p\">[:</span><span class=\"mi\">8</span><span class=\"p\">])</span>    <span class=\"c1\"># WIF = Wallet Import Format -&gt; 비트코인 거래를 위한 약식 개인키</span>    <span class=\"n\">WIF</span> <span class=\"o\">=</span> <span class=\"n\">b58encode</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">)</span>    <span class=\"c1\"># 1단계 ECDSA 공개키 획득</span>    <span class=\"n\">signing_key</span> <span class=\"o\">=</span> <span class=\"n\">ecdsa</span><span class=\"p\">.</span><span class=\"n\">SigningKey</span><span class=\"p\">.</span><span class=\"n\">from_string</span><span class=\"p\">(</span><span class=\"n\">privkey</span><span class=\"p\">,</span> <span class=\"n\">curve</span><span class=\"o\">=</span><span class=\"n\">ecdsa</span><span class=\"p\">.</span><span class=\"n\">SECP256k1</span><span class=\"p\">)</span>    <span class=\"n\">verifying_key</span> <span class=\"o\">=</span> <span class=\"n\">signing_key</span><span class=\"p\">.</span><span class=\"n\">get_verifying_key</span><span class=\"p\">()</span>    <span class=\"n\">pubkey</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">verifying_key</span><span class=\"p\">.</span><span class=\"n\">to_string</span><span class=\"p\">()).</span><span class=\"nb\">hex</span><span class=\"p\">()</span>    <span class=\"c1\"># 2단계</span>    <span class=\"n\">pubkey</span> <span class=\"o\">=</span> <span class=\"s\">\"04\"</span> <span class=\"o\">+</span> <span class=\"n\">pubkey</span>    <span class=\"c1\"># 3단계</span>    <span class=\"n\">pub_sha</span> <span class=\"o\">=</span> <span class=\"n\">sha</span><span class=\"p\">(</span><span class=\"nb\">bytes</span><span class=\"p\">.</span><span class=\"n\">fromhex</span><span class=\"p\">(</span><span class=\"n\">pubkey</span><span class=\"p\">)).</span><span class=\"n\">digest</span><span class=\"p\">()</span>    <span class=\"n\">encPubkey</span> <span class=\"o\">=</span> <span class=\"n\">ripemd160</span><span class=\"p\">(</span><span class=\"n\">pub_sha</span><span class=\"p\">).</span><span class=\"n\">digest</span><span class=\"p\">()</span>    <span class=\"c1\"># 4단계</span>    <span class=\"n\">encPubkey</span> <span class=\"o\">=</span> <span class=\"sa\">b</span><span class=\"s\">\"</span><span class=\"se\">\\x00</span><span class=\"s\">\"</span> <span class=\"o\">+</span> <span class=\"n\">encPubkey</span>    <span class=\"c1\"># 5단계</span>    <span class=\"n\">chunck</span> <span class=\"o\">=</span> <span class=\"n\">sha</span><span class=\"p\">(</span><span class=\"n\">sha</span><span class=\"p\">(</span><span class=\"n\">encPubkey</span><span class=\"p\">).</span><span class=\"n\">digest</span><span class=\"p\">()).</span><span class=\"n\">digest</span><span class=\"p\">()</span>    <span class=\"c1\"># 6단계</span>    <span class=\"n\">checksum</span> <span class=\"o\">=</span> <span class=\"n\">chunck</span><span class=\"p\">[:</span><span class=\"mi\">4</span><span class=\"p\">]</span>    <span class=\"c1\"># 7단계</span>    <span class=\"n\">hex_address</span> <span class=\"o\">=</span> <span class=\"n\">encPubkey</span> <span class=\"o\">+</span> <span class=\"n\">checksum</span>    <span class=\"c1\"># 8단계</span>    <span class=\"n\">bitcoinAdress</span> <span class=\"o\">=</span> <span class=\"n\">b58encode</span><span class=\"p\">(</span><span class=\"n\">hex_address</span><span class=\"p\">)</span>    <span class=\"c1\"># WIF와 생성된 비트코인 주소 출력</span>    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"+++WIF = \"</span><span class=\"p\">,</span> <span class=\"n\">WIF</span><span class=\"p\">.</span><span class=\"n\">decode</span><span class=\"p\">())</span>    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"+++Bitcoin Adress = \"</span><span class=\"p\">,</span> <span class=\"n\">bitcoinAdress</span><span class=\"p\">.</span><span class=\"n\">decode</span><span class=\"p\">())</span><span class=\"n\">generateBitcoinAdress</span><span class=\"p\">()</span></code></pre></div></div>",
            "url": "https://0o3q.github.io/2023/04/12/blockchain-with-bitcoin",
            
            
            
            "tags": ["해시","블록체인","비트코인"],
            
            "date_published": "2023-04-12T00:00:00+09:00",
            "date_modified": "2023-04-12T00:00:00+09:00",
            
                "author":  {
                "name": "0o3q",
                "url": null,
                "avatar": null
                }
                
            
        }
    
    ]
}